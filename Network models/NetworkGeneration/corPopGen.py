##get distribution of first-time birth
##get distributon of time between children
##get distribution of number of children
##generate sibling flocks/households from this and age distribution data

#get distribution in age for region
#distribute these people across baskets corresponding to sibling flock size (do we need to account for larger sibling flocks than 6? that's where the data caps out)
#generate sibling flocks from baskets (move remnants down progressively from highest to lowest)
#distribute sibling flocks to parents based on data on 

#SINGLE PARENT OR NOT IS IMPORTANT! 
## Living with both parents, total	
#Children with no siblings	127 194
#Children with siblings, total	709 612 
#TOT = 836,806
## Living with one of the parents, total	
#Children with no siblings	99 231
#Children with siblings, total	175 450
#TOT = 274,681â€¬
## Fractions with both/single parents
#No siblings 0.56/0.44
#Siblings 0.80/0.20
#TOT 0.75/0.25


import pandas as pd
import random
import warnings
import copy
import math
import os


# # # # #
# # # # # Functions to get the different distributions from the csv files generated by croPopDat.py
# # # # #

def getAgeDistribution(queryMunicipality,dirname):
    #07459: Population, by sex and one-year age groups (M) 1986 - 2020
    pop_age_region_dataFrame = pd.read_csv(dirname+"pop_age_region.csv")
    osloAges = pop_age_region_dataFrame.loc[pop_age_region_dataFrame['region'] == queryMunicipality]
    ageDistribution = []
    for i in range(106):
        queryAge = str(i)+" years"
        if i==1:
            queryAge = "1 year"
        ageVals = osloAges.loc[osloAges['age'] == queryAge]
        ageDistribution.append(sum(ageVals['value']))
    return ageDistribution

def getHouseholdSizeDistribution(queryMunicipality,dirname):
    #distribution of household sizes
    #06079: Private households and persons in private households, by size of household (per cent) (M) (UD) 2005 - 2019
    household_sizes_dataFrame = pd.read_csv(dirname+"household_sizes.csv")
    regionHouseholds = household_sizes_dataFrame.loc[household_sizes_dataFrame['region'] == queryMunicipality]
    regionHouseholds = regionHouseholds.loc[regionHouseholds['contents'] == 'Persons in private households']
    regionHouseholds['value'].tolist()
    return regionHouseholds['value'].tolist()

def getHouseHoldTypeDistribution(queryMunicipality,dirname):
    #06070: Privathusholdninger, etter husholdningstype (K) (B) 2005 - 2019
    household_type_dataFrame = pd.read_csv(dirname+"household_type.csv")
    regionHouseholds = household_type_dataFrame.loc[household_type_dataFrame['region'] == queryMunicipality]
    # print(regionHouseholds)
    householdTypes = ["Living alone","Couple without resident children","Couple with small children (youngest child 0-5 years)","Couple with older children (youngest child 6-17 years)","Lone parent with small children (youngest child 0-5 years)","Lone parent with older children (youngest child 6-17 years)","One family households with adult children (youngest child 18 years and over","Two or more-family households without resident children 0-17 years","Two or more-family households with small children (youngest child 0-5 years)","Two or more-family households with older children (youngest child 6-17 years)"]
    householdNumbers = []
    for i in householdTypes:
        householdNumbers.append(sum(regionHouseholds.loc[regionHouseholds['type of household'] == i]['value']))
    assert len(householdTypes)==len(householdNumbers)
    householdData = [householdTypes,householdNumbers]
    # 0 "Living alone"
    # 1 "Couple without resident children"
    # 2 "Couple with small children (youngest child 0-5 years)"
    # 3 "Couple with older children (youngest child 6-17 years)"
    # 4 "Lone parent with small children (youngest child 0-5 years)"
    # 5 "Lone parent with older children (youngest child 6-17 years)"
    # 6 "One family households with adult children (youngest child 18 years and over"
    # 7 "Two or more-family households without resident children 0-17 years"
    # 8 "Two or more-family households with small children (youngest child 0-5 years)"
    # 9 "Two or more-family households with older children (youngest child 6-17 years)"
    return householdData

def getSiblingFlockSizeDistribution(dirname):
    #06206: Children 0-17 years, by number of siblings and the child's age 2001 - 2019
    #child_sibs_age_dataFrame = pd.read_csv(dirname+"child_sibs_age.csv")
    #Sibling flock size, fraction by number: 1, 2, 3, 4, 5, 6+
    siblingFlockSizeDistribution = [0.197,0.584*0.803,0.311*0.803,0.073*0.803,0.019*0.803,0.012*0.803]
    for i in range(len(siblingFlockSizeDistribution)):
        siblingFlockSizeDistribution[i] = siblingFlockSizeDistribution[i]/(1+i)
    siblingFlockSum = sum(siblingFlockSizeDistribution[1:])
    for i in range(len(siblingFlockSizeDistribution)-1):
        siblingFlockSizeDistribution[i+1] = 0.803*siblingFlockSizeDistribution[i+1]/siblingFlockSum
    assert sum(siblingFlockSizeDistribution)>0.99 and sum(siblingFlockSizeDistribution)<1.01
    return siblingFlockSizeDistribution
    
def getSecondaryEducationProportion(dirname):
    #08947: Pupils, apprentices, students and participants in upper secondary education, by sex, age and type of school/institution 2006 - 2019
    #upper_secondary_schoolers_dataFrame = pd.read_csv(dirname+"upper_secondary_schoolers.csv")
    #2,"Public maintained schools, total",Both sexes,16-18 years,"Pupils, apprentices, students and participants",2019,176923
    #3,"Public maintained schools, total",Both sexes,19-24 years,"Pupils, apprentices, students and participants",2019,58448
    #total number of people 16-24 in upper secondary school: 176923+58448=235371
    #total proportion of people 16-24 in upper secondary school: 235371/(32300+31684+32696+34517+34794+34159+35129+36127+36264+30722+30367+30861+32067+32019+32005+32688+33822+33822)=0.394
    #people 16-20 divided by people 16-24 in upper secondary school: 235371/(32300+31684+32696+34517+34794+30722+30367+30861+32067+32019)=0.731
    # 16,The whole country,Males,16 years,Persons,2020,32300
    # 17,The whole country,Males,17 years,Persons,2020,31684
    # 18,The whole country,Males,18 years,Persons,2020,32696
    # 19,The whole country,Males,19 years,Persons,2020,34517
    # 20,The whole country,Males,20 years,Persons,2020,34794
    # 21,The whole country,Males,21 years,Persons,2020,34159
    # 22,The whole country,Males,22 years,Persons,2020,35129
    # 23,The whole country,Males,23 years,Persons,2020,36127
    # 24,The whole country,Males,24 years,Persons,2020,36264
    # 122,The whole country,Females,16 years,Persons,2020,30722
    # 123,The whole country,Females,17 years,Persons,2020,30367
    # 124,The whole country,Females,18 years,Persons,2020,30861
    # 125,The whole country,Females,19 years,Persons,2020,32067
    # 126,The whole country,Females,20 years,Persons,2020,32019
    # 127,The whole country,Females,21 years,Persons,2020,32005
    # 128,The whole country,Females,22 years,Persons,2020,32688
    # 129,The whole country,Females,23 years,Persons,2020,33822
    # 130,The whole country,Females,24 years,Persons,2020,33822
    warnings.warn("WARNING! SECONDARY EDUCATION PROPORTION DATA IS GUESSTIMATE")
    return 0.6

def getWorkplaceSizeDistribution(queryMunicipality,dirname):
    #10308: Establishments, by the enterprises sector and number of employees (M) 2012 - 2020
    establishments_dataFrame = pd.read_csv(dirname+"establishments.csv")
    regionEstablishments = establishments_dataFrame.loc[establishments_dataFrame['region'] == queryMunicipality]
    employeeBins = ["1-4 employees","5-9 employees","10-19 employees","20-49 employees","50-99 employees","100 - 249 employees","250 employees and more"]
    employeeNumbers = []
    for i in employeeBins:
        employeeNumbers.append(sum(regionEstablishments.loc[regionEstablishments['number of employees'] == i]['value']))
    assert len(employeeBins) == len(employeeNumbers)
    return [employeeBins,employeeNumbers]

def getSchoolSizeDistribution(queryMunicipality,dirname):

    #loading data
    allSchools_dataFrame = pd.read_csv(dirname+"allSchools.csv")
    regionSchools = allSchools_dataFrame.loc[allSchools_dataFrame['KommuneNavn'] == queryMunicipality]
    # print("len(regionSchools['KommuneNavn'])")
    if len(regionSchools['KommuneNavn']) == 0:
        print("Data for schools in "+queryMunicipality+" is missing.")
        
    lowerSchools = regionSchools.loc[regionSchools['ErGrunnSkole'] == True]
    upperSchools = regionSchools.loc[regionSchools['ErVideregaaendeSkole'] == True]
    # upperSchools.to_csv(dirname+'upperSchools_'+queryMunicipality+'.csv')
    # print(upperSchools)

    #converting number of pupils, school steps and employees to lists
    lowerSchoolPupilNumber = lowerSchools['Elevtall'].tolist()
    lowerSchoolStepFrom = lowerSchools['SkoleTrinnFra'].tolist()
    lowerSchoolStepTo = lowerSchools['SkoleTrinnTil'].tolist()
    # lowerSchoolEmployeesFrom = lowerSchools['AnsatteFra'].tolist()
    # lowerSchoolEmployeesTo = lowerSchools['AnsatteTil'].tolist()

    #converting number of pupils, school steps and employees to lists
    upperSchoolPupilNumber = upperSchools['Elevtall'].tolist()
    upperSchoolStepFrom = upperSchools['SkoleTrinnFra'].tolist()
    upperSchoolStepTo = upperSchools['SkoleTrinnTil'].tolist()
    # upperSchoolEmployeesFrom = upperSchools['AnsatteFra'].tolist()
    upperSchoolEmployeesTo = upperSchools['AnsatteTil'].tolist()


    #generating lower school sizes

    primarySchoolSizes = []
    secondarySchoolSizes = []

    for school in range(len(lowerSchoolPupilNumber)):
        if lowerSchoolStepFrom[school]==1 and lowerSchoolStepTo[school]==7:
            primarySchoolSizes.append(lowerSchoolPupilNumber[school])
        elif lowerSchoolStepFrom[school] == 8 and lowerSchoolStepTo[school] == 10:
            secondarySchoolSizes.append(lowerSchoolPupilNumber[school])
        elif lowerSchoolStepFrom[school]==1 and lowerSchoolStepTo[school]==10:
            primarySchoolSizes.append(int(0.7*lowerSchoolPupilNumber[school]))
            secondarySchoolSizes.append(int(0.3*lowerSchoolPupilNumber[school]))
        elif lowerSchoolStepFrom[school]==1 and lowerSchoolStepTo[school]==13:
            primarySchoolSizes.append(int(7/13*lowerSchoolPupilNumber[school]))
            secondarySchoolSizes.append(int(3/13*lowerSchoolPupilNumber[school]))
        elif lowerSchoolStepFrom[school]==1 and lowerSchoolStepTo[school]==12:
            primarySchoolSizes.append(int(7/12*lowerSchoolPupilNumber[school]))
            secondarySchoolSizes.append(int(3/12*lowerSchoolPupilNumber[school]))
        elif lowerSchoolStepFrom[school]==8 and lowerSchoolStepTo[school]==13:
            secondarySchoolSizes.append(int(0.5*lowerSchoolPupilNumber[school]))
        elif lowerSchoolStepFrom[school]==1 and lowerSchoolStepTo[school]==6:
            primarySchoolSizes.append(lowerSchoolPupilNumber[school])
        # else:
            # print("lowerSchoolStepFrom[school]: "+str(lowerSchoolStepFrom[school])+", lowerSchoolStepTo[school]: "+str(lowerSchoolStepTo[school])+", lowerSchoolPupilNumber[school]: "+str(lowerSchoolPupilNumber[school]))


    #generating upper school sizes
    
    secondarySchoolSizeDistribution = []
    
    for school in range(len(upperSchoolPupilNumber)):
        #numbers are missing for many upper secondary schools
        if math.isnan(upperSchoolPupilNumber[school]):
            #there appears to be numbers for employees for a lot more, and there appears to be roughly (read: sketchy approximation) 4.5 students per employee
            sketchyApproximation = upperSchoolEmployeesTo[school]*4.5
            if math.isnan(sketchyApproximation):
                sketchyApproximation = 0
            upperSchoolPupilNumber[school] = int(sketchyApproximation)
        if upperSchoolStepFrom[school] == 11 and upperSchoolStepTo[school] == 13:
            secondarySchoolSizeDistribution.append(upperSchoolPupilNumber[school])
        elif upperSchoolStepFrom[school] == 8 and upperSchoolStepTo[school] == 13:
            secondarySchoolSizeDistribution.append(int(0.5*upperSchoolPupilNumber[school]))
        elif upperSchoolStepFrom[school] == 1 and upperSchoolStepTo[school] == 13:
            secondarySchoolSizeDistribution.append(int(3/13*upperSchoolPupilNumber[school]))
        elif upperSchoolStepFrom[school] == 1 and upperSchoolStepTo[school] == 12:
            secondarySchoolSizeDistribution.append(int(2/12*upperSchoolPupilNumber[school]))
        # else:
        #     print("upperSchoolStepFrom[school]: "+str(upperSchoolStepFrom[school])+", upperSchoolStepTo[school]: "+str(upperSchoolStepTo[school])+", upperSchoolPupilNumber[school]: "+str(upperSchoolPupilNumber[school]))


    #associating primary schools with lower secondary schools, generating implicit geographical linkage
    if not len(primarySchoolSizes)>len(secondarySchoolSizes):
        print("primarySchoolSizes:")
        print(primarySchoolSizes)
        print("secondarySchoolSizes:")
        print(secondarySchoolSizes)
    assert(len(primarySchoolSizes)>len(secondarySchoolSizes))
    primarySchoolSizes.sort(reverse = True)
    secondarySchoolSizes.sort(reverse = True)
    
    schoolAssociations = [[] for x in range(len(secondarySchoolSizes))] #linking each secondary schools to set of primary schools. index is secondary school, values are lists of primary schools

    #iteratively assigning the biggest primary school to the secondary school with the largest proportional amount of spaces left
    secondarySchoolSlotsVacant = copy.deepcopy(secondarySchoolSizes)
    for school in range(len(primarySchoolSizes)):
        schoolIndex = secondarySchoolSlotsVacant.index(max(secondarySchoolSlotsVacant))
        schoolAssociations[schoolIndex].append(school)
        secondarySchoolSlotsVacant[schoolIndex] = secondarySchoolSlotsVacant[schoolIndex]-int(3*primarySchoolSizes[school])

    return [primarySchoolSizes,secondarySchoolSizes,schoolAssociations],secondarySchoolSizeDistribution #schoolAssocations has secondary school ID as index and primary school IDs as value

def getElderlyHomeDistribution(queryMunicipality,queryCounty,dirname):
    #09929: Nursing and care institutions and beds, by ownership (C) 2009 - 2018
    # nursing_spots_dataFrame = pd.read_csv(dirname+"nursing_spots.csv")

    #11933: Care institutions - rooms, by region, contents and year (M)
    nursingHomeRooms_dataFrame = pd.read_csv(dirname+"nursingHomeRooms.csv")

    #generating nursing home size distribution by dividing the number of beds by the number of institutions and assuming some kind of middle-heavy distribution
    #generating nursing homes number by dividing number of patients by average nursing home size
    #distribution below is "weighting for each bin of 10"

    regionNursingHomeRooms = nursingHomeRooms_dataFrame[nursingHomeRooms_dataFrame['region'].str.contains(queryMunicipality)]
    numberOfRooms = sum(regionNursingHomeRooms.loc[regionNursingHomeRooms['contents'] == "Rooms, total (number)"]['value'])

    # regionNursingSpots = nursing_spots_dataFrame[nursing_spots_dataFrame['region'].str.contains(queryCounty)]
    # regionNursingSpots = regionNursingSpots[regionNursingSpots['ownership'].str.contains("total")]
    # numberOfBeds = sum(regionNursingSpots.loc[regionNursingSpots['contents'] == "Beds"]['value'])
    # numberOfInstitutions = sum(regionNursingSpots.loc[regionNursingSpots['contents'] == "Institutions"]['value'])
    
    # meanNursingHomeSize = numberOfBeds/numberOfInstitutions

    #setting mean nursing home size to 40; it's 50 for Oslo, assuming smaller average
    meanNursingHomeSize = 40
    if math.isnan(numberOfRooms):
        numberOfRooms = 0
    numberOfInstitutions = int(numberOfRooms/meanNursingHomeSize)
    if numberOfInstitutions == 0 and numberOfRooms>0:
        numberOfInstitutions = 1
    nursingHomeSizes = [meanNursingHomeSize for x in range(numberOfInstitutions)]

    #04469: Bebuarar i bustader kommunen disponerer til pleie- og omsorgsformÃ¥l, etter alder (K) 2002 - 2018
    nursing_patients_dataFrame = pd.read_csv(dirname+"nursing_patients.csv")
    regionNursingHomes = nursing_patients_dataFrame.loc[nursing_patients_dataFrame['region'] == queryMunicipality]
    regionNursingHomes = regionNursingHomes.loc[nursing_patients_dataFrame['contents'] == 'Residents in dwellings']
    ageBins = ["Under 67 years","67-74 years","75-79 years","80-84 years","85-89 years","90 years or older"]
    ageNumbers = []
    for i in ageBins:
        numberAtAge = sum(regionNursingHomes.loc[regionNursingHomes['age'].isin([i])]['value'])
        if math.isnan(numberAtAge):
            print("Nursing home resident information unavailable! Default distribution assumed")
            meanAgeGroupSize = int(numberOfRooms/len(ageBins))
            ageGroupWeights = [0.5,0.5,0.8,1.2,1.5,1.5]
            assert sum(ageGroupWeights)/len(ageGroupWeights) == 1
            ageNumbers = [int(meanAgeGroupSize*ageGroupWeights[x]) for x in range(len(ageBins))]
            break
        else:
            ageNumbers.append(int(numberAtAge))
    assert len(ageBins) == len(ageNumbers)

    # print("numberOfRooms: "+str(numberOfRooms)+", total patients: "+str(sum(ageNumbers)))
    # print("Age distribution: u67: "+str(ageNumbers[0])+", 67-74: "+str(ageNumbers[1])+", 75-79: "+str(ageNumbers[2])+", 80-84: "+str(ageNumbers[3])+", 85-89: "+str(ageNumbers[4])+", 90+: "+str(ageNumbers[5]))

    # #determining number of nursing homes
    # numberOfNursingHomes = int(sum(ageNumbers)/meanNursingHomeSize)
    # #generating nursing homes
    # population = range(len(nursingHomeSizeDistribution))
    # weights = copy.deepcopy(nursingHomeSizeDistribution)
    # nursingHomeSizes = []
    # for i in range(numberOfNursingHomes):
    #     nursingHomeSize = random.choices(population, weights)
    #     nursingHomeSize = nursingHomeSize[0]
    #     nursingHomeSizes.append(nursingHomeSize)

    return nursingHomeSizes,[ageBins,ageNumbers]

def getKindergartenDistribution(queryMunicipality,dirname):
    
    #   loading relevant data

    #09220: Kindergartens, by ownership (M) 1987 - 2019
    kids_in_kindergartens_dataFrame = pd.read_csv(dirname+'kindergartenNumbers.csv')
    kindergartensRegion = kids_in_kindergartens_dataFrame.loc[kids_in_kindergartens_dataFrame['region'] == queryMunicipality]
    
    #09169: Barn i barnehager, etter region, barnehagetype, statistikkvariabel og Ã¥r
    kindergartens_in_places = pd.read_csv(dirname+'kidsInKindergartens.csv')
    kindergartenKidsRegion = kindergartens_in_places.loc[kindergartens_in_places['region'] == queryMunicipality]

    #12562: Selected key figures kindergartens, by region, contents and year
    kinderGartenAttendanceAndPersonnel = pd.read_csv(dirname+'kinderGartenAttendanceAndPersonnel.csv')
    kinderGartenAttendanceAndPersonnelRegion = kinderGartenAttendanceAndPersonnel.loc[kinderGartenAttendanceAndPersonnel['region'] == queryMunicipality]
    #"Percentage of 1-2 year-olds in kindergarten (per cent)", "Percentage of 3-5 year-olds in kindergarten (per cent)"
    smallKidsRates = sum(kinderGartenAttendanceAndPersonnelRegion.loc[kinderGartenAttendanceAndPersonnelRegion['contents'] == "Percentage of 1-2 year-olds in kindergarten (per cent)"]['value'])
    bigKidsRates = sum(kinderGartenAttendanceAndPersonnelRegion.loc[kinderGartenAttendanceAndPersonnelRegion['contents'] == "Percentage of 3-5 year-olds in kindergarten (per cent)"]['value'])

    ageGroups = ["0 years","1 year","2 years","3 years","4 years","5 years","6 years"]
    numberOfKidsPerYear = [sum(kindergartenKidsRegion.loc[kindergartenKidsRegion['age'] == ageGroups[i]]['value']) for i in range(7)]
    numberOfKids = sum(numberOfKidsPerYear)

    numberOfKindergartens = sum(kindergartensRegion['value'])

    #assuming (somewhat naively) homogeneous size of kindergartens in lieu of better data
    meanKindergartenSize = int(numberOfKids/numberOfKindergartens)
    
    kindergartenSizes = [meanKindergartenSize for x in range(numberOfKindergartens)]
    kindergartenProportions = [0]+[smallKidsRates/100 for x in range(2)]+[bigKidsRates/100 for x in range(3)]

    return kindergartenSizes,kindergartenProportions



# Function for building social network

def generateSocialNetworkForRegion(municipalityToGet):

    print("Generating network for "+municipalityToGet)

    dirname = os.path.dirname(__file__)
    dirname = dirname+"/populationData/"
    
    #since some data only exists with county (fylke) resolution, and not municipality (kommune) resolution,
    # a conversion is required:
    countyToGet = "Oslo"
    if municipalityToGet != "Oslo":
        county_municipality_table = pd.read_csv(dirname+"fylke_kommune_oldnew.txt",delimiter = "\t")
        municipalityList = county_municipality_table['Kommune 2019'].tolist()
        countyList = county_municipality_table['Fylke 2019'].tolist()
        for i in range(len(municipalityList)):
            if municipalityToGet.upper() in municipalityList[i]:
                countyToGet = countyList[i]
                break
        countyToGet = countyToGet.split()
        if len(countyToGet)>1:
            countyToGet = countyToGet[1]
        countyToGet = countyToGet.lower()
        countyToGet = countyToGet.capitalize()

    #people of different ages, index is age, value is number of people
    #Dataset from SSB: "07459: Population, by sex and one-year age groups (M) 1986 - 2020"
    ageDistribution = getAgeDistribution(municipalityToGet,dirname)

    print("Age distribution: 67-74: "+str(sum(ageDistribution[67:75]))+", 75-79: "+str(sum(ageDistribution[75:80]))+", 80-84: "+str(sum(ageDistribution[80:85]))+", 85-89: "+str(sum(ageDistribution[85:90]))+", 90+: "+str(sum(ageDistribution[90:])))

    #distribution of household sizes, index+1 is number of people, value is proportion
    #Dataset from SSB: "06079: Private households and persons in private households, by size of household (per cent) (M) (UD) 2005 - 2019"
    householdSizeDistribution = getHouseholdSizeDistribution(countyToGet,dirname)

    #distribtion of households: 2 parents, single parents, number of children distribution for each. age?
    #Dataset from SSB: "#06070: Privathusholdninger, etter husholdningstype (K) (B) 2005 - 2019"
    householdTypeDistribution = getHouseHoldTypeDistribution(municipalityToGet,dirname)
    #removing two or more-family households due to uncertainty around how to integrate data; but is significant proportion! (18585/341468 ~ 5% in Oslo)
    householdTypeDistribution[0] = householdTypeDistribution[0][0:7]
    householdTypeDistribution[1] = householdTypeDistribution[1][0:7]

    #distribution on number of siblings in flock
    #Dataset from SSB: "#06206: Children 0-17 years, by number of siblings and the child's age 2001 - 2019"
    siblingFlockSizeDistribution = getSiblingFlockSizeDistribution(dirname)

    #proportion of 16-20 YO in upper secondary education
    #Dataset from SSB: "#08947: Pupils, apprentices, students and participants in upper secondary education, by sex, age and type of school/institution 2006 - 2019"
    secondaryEducationProportion = getSecondaryEducationProportion(dirname)

    #distribution of workplace sizes
    #Dataset from SSB: "#10308: Establishments, by the enterprises sector and number of employees (M) 2012 - 2020"
    workplaceSizeDistribution = getWorkplaceSizeDistribution(municipalityToGet,dirname)

    #distribution of school sizes and types
    # schoolDistributions - [primarySchoolSizes,secondarySchoolSizes,schoolAssociations]
    # schoolAssocations has secondary school ID as index and primary school IDs as value
    # upperSecondarySchoolDistribution - [schoolSize1,schoolSize2,...]
    #Dataset from NSR API: "https://data-nsr.udir.no/"
    schoolDistributions,upperSecondarySchoolDistribution = getSchoolSizeDistribution(municipalityToGet,dirname)

    #distribution of elderly home sizes and patient number distribution by age
    #Datasets from SSB:
        # "#09929: Nursing and care institutions and beds, by ownership (C) 2009 - 2018"
        # "#04469: Bebuarar i bustader kommunen disponerer til pleie- og omsorgsformÃ¥l, etter alder (K) 2002 - 2018"
        # "#11933: Care institutions - rooms, by region, contents and year"
    nursingHomeSizes,nursingHomePatientDistribution = getElderlyHomeDistribution(municipalityToGet,countyToGet,dirname)

    #distribution of kindergartens and kindergarten slots
    #Datasets from SSB:
        # "#09220: Kindergartens, by ownership (M) 1987 - 2019"
        # "#09169: Barn i barnehager, etter region, barnehagetype, statistikkvariabel og Ã¥r"
        # "#12562: Selected key figures kindergartens, by region, contents and year"
    kindergartenSizes,kindergartenProportions = getKindergartenDistribution(municipalityToGet,dirname)

    # # # # #
    # # # # # Building households
    # # # # #

    #finding total numbers of households, adults and children
    numberHouseholds = sum(householdTypeDistribution[1])
    numberUnassignedAdults = sum(ageDistribution[18:])
    numberUnassignedChildren = sum(ageDistribution[0:18])

    #finding age probability distribution
    ageProbDist = [x/(numberUnassignedAdults+numberUnassignedChildren) for x in ageDistribution]

    assert numberUnassignedAdults + numberUnassignedChildren == sum(ageDistribution)

    #generating households

    peopleAgeList = []
    householdPeopleList = []

    households = [] #id, age
    peopleIDs = 1
    householdsPicked = [0 for x in range(10)]
    for i in range(numberHouseholds):
        population = [x for x in range(len(householdTypeDistribution[0]))]
        weights = copy.deepcopy(householdTypeDistribution[1])
        householdType = random.choices(population, weights)
        householdType = householdType[0]
        age = 0
        household = []
        if householdType == 0:
            householdsPicked[0] = householdsPicked[0]+1
            #Living alone
            population = range(len(ageDistribution))
            weights = copy.deepcopy(ageDistribution)
            for i in range(len(ageDistribution)):
                #assuming people 20-65 are 1/3 as likely to live alone
                if i>=20 and i<=65:
                    weights[i] = weights[i]*(1/3)
                #assuming people under 18 don't live alone
                if i<=18:
                    weights[i] = weights[i]*0
            age = random.choices(population, weights)
            age = age[0]
            household.append([peopleIDs,age])
            peopleIDs = peopleIDs+1
        elif householdType == 1:
            householdsPicked[1] = householdsPicked[1]+1
            #Couple without resident children
            population = range(len(ageDistribution))
            weights = copy.deepcopy(ageDistribution)
            for i in range(len(ageDistribution)):
                #assuming people 30-50 are 1/3 as likely to be childless
                if i>=30 and i<=50:
                    weights[i] = weights[i]*(1/3)
                #assuming people under 18 don't live as couples
                if i<=18:
                    weights[i] = weights[i]*0
            for i in range(2):
                age = random.choices(population, weights)
                age = age[0]
                household.append([peopleIDs,age])
                peopleIDs = peopleIDs+1
        elif householdType == 2:
            householdsPicked[2] = householdsPicked[2]+1
            #Couple with small children (youngest child 0-5 years)
            population = range(len(ageDistribution))
            weights = copy.deepcopy(ageDistribution)
            #assuming people under 18 and over 60 don't have small children
            for i in range(len(ageDistribution)):
                if i<=18 or i>=50:
                    weights[i] = weights[i]*0
            #parents' age are assumed to be uncorrelated
            for i in range(2):
                age = random.choices(population, weights)
                age = age[0]
                household.append([peopleIDs,age])
                peopleIDs = peopleIDs+1
            #sibling flock size is assumed to be selected from standard distribution
            population = range(len(siblingFlockSizeDistribution))
            weights = copy.deepcopy(siblingFlockSizeDistribution)
            flockSize = random.choices(population, weights)
            flockSize = flockSize[0]+1 #adding +1 since index 0 is size 1
            for i in range(flockSize):
                population = range(len(ageDistribution[0:18]))
                weights = ageDistribution[0:18]
                age = random.choices(population, weights)
                age = age[0]
                household.append([peopleIDs,age])
                peopleIDs = peopleIDs+1
        elif householdType == 3:
            householdsPicked[3] = householdsPicked[3]+1
            #Couple with older children (youngest child 6-17 years)
            population = range(len(ageDistribution))
            weights = copy.deepcopy(ageDistribution)
            #assuming people under 25 and over 65 don't have older children
            for i in range(len(ageDistribution)):
                if i<=25 or i>=65:
                    weights[i] = weights[i]*0
            #parents' age are assumed to be uncorrelated
            for i in range(2):
                age = random.choices(population, weights)
                age = age[0]
                household.append([peopleIDs,age])
                peopleIDs = peopleIDs+1
            #sibling flock size is assumed to be between 1 and 3
            population = range(len(siblingFlockSizeDistribution[0:4]))
            weights = copy.deepcopy(siblingFlockSizeDistribution[0:4])
            flockSize = random.choices(population, weights)
            flockSize = flockSize[0]+1 #adding +1 since index 0 is size 1
            for i in range(flockSize):
                population = range(len(ageDistribution[6:18]))
                weights = ageDistribution[6:18]
                age = random.choices(population, weights)
                age = age[0]
                household.append([peopleIDs,age])
                peopleIDs = peopleIDs+1
        elif householdType == 4:
            householdsPicked[4] = householdsPicked[4]+1
            #Lone parent with small children (youngest child 0-5 years)
            population = range(len(ageDistribution))
            weights = copy.deepcopy(ageDistribution)
            #assuming people under 18 and over 60 don't have small children
            for i in range(len(ageDistribution)):
                if i<=18 or i>=50:
                    weights[i] = weights[i]*0
            age = random.choices(population, weights)
            age = age[0]
            household.append([peopleIDs,age])
            peopleIDs = peopleIDs+1
            #sibling flock size is considered 1/4 as likely to be larger than 1
            population = range(len(siblingFlockSizeDistribution))
            weights = copy.deepcopy(siblingFlockSizeDistribution)
            for i in range(len(siblingFlockSizeDistribution)):
                if i>0:
                    weights[i] = weights[i]*(1/4)
            flockSize = random.choices(population, weights)
            flockSize = flockSize[0]+1 #adding +1 since index 0 is size 1
            for i in range(flockSize):
                population = range(len(ageDistribution[0:18]))
                weights = copy.deepcopy(ageDistribution[0:18])
                age = random.choices(population, weights)
                age = age[0]
                household.append([peopleIDs,age])
                peopleIDs = peopleIDs+1
        elif householdType == 5:
            householdsPicked[5] = householdsPicked[5]+1
            #Lone parent with older children (youngest child 6-17 years)
            population = range(len(ageDistribution))
            weights = copy.deepcopy(ageDistribution)
            #assuming people under 25 and over 65 don't have older children
            for i in range(len(ageDistribution)):
                if i<=25 or i>=65:
                    weights[i] = weights[i]*0
            age = random.choices(population, weights)
            age = age[0]
            household.append([peopleIDs,age])
            peopleIDs = peopleIDs+1
            #sibling flock size is assumed to be between 1 and 3, and to be 1/4 as likely to be larger than 1
            population = range(len(siblingFlockSizeDistribution[0:4]))
            weights = copy.deepcopy(siblingFlockSizeDistribution[0:4])
            for i in range(len(siblingFlockSizeDistribution[0:4])):
                if i>0:
                    weights[i] = weights[i]*(1/4)
            flockSize = random.choices(population, weights) #adding +1 since index 0 is size 1
            flockSize = flockSize[0]+1 #adding +1 since index 0 is size 1
            for i in range(flockSize):
                population = range(len(ageDistribution[6:18]))
                weights = copy.deepcopy(ageDistribution[6:18])
                age = random.choices(population, weights)
                age = age[0]
                household.append([peopleIDs,age])
                peopleIDs = peopleIDs+1
        elif householdType == 6:
            householdsPicked[6] = householdsPicked[6]+1
            #One family households with adult children (youngest child 18 years and over
            population = range(len(ageDistribution))
            weights = copy.deepcopy(ageDistribution)
            #assuming people with moved-out children are 45 or up
            for i in range(len(ageDistribution)):
                if i<=45:
                    weights[i] = weights[i]*0
            for i in range(2):
                age = random.choices(population, weights)
                age = age[0]
                household.append([peopleIDs,age])
                peopleIDs = peopleIDs+1
        else:
            raise Exception("Missing case in household type selection")
        # elif householdType == 7:
        #     #Two or more-family households without resident children 0-17 years
        # elif householdType == 8:
        #     #Two or more-family households with small children (youngest child 0-5 years)
        # elif householdType == 9:
        #     #Two or more-family households with older children (youngest child 6-17 years)'
        for person in household:
            peopleAgeList.append(person)
            householdPeopleList.append([i,person[0]])
        households.append(household)

    #assigning households to lower secondary schools
    #schoolDistributions - [primarySchoolSizes,secondarySchoolSizes,schoolAssociations] #schoolAssocations has secondary school ID as index and primary school IDs as value
    householdsSchoolAffiliation = []
    population = range(len(schoolDistributions[1]))
    weights = copy.deepcopy(schoolDistributions[1])
    for i in range(numberHouseholds):
        schoolIndex = random.choices(population, weights)
        schoolIndex = schoolIndex[0]
        householdsSchoolAffiliation.append(schoolIndex)

    #assigning children to kindergartens
    #assigning kids to kindergartens randomly according to size weights and age attendance proportion
    #kindergartenSizes - [size1, size2, ...]
    kindergartens = [[] for x in range(len(kindergartenSizes))]
    population = range(len(kindergartens))
    weights = copy.deepcopy(kindergartenSizes)
    for hh in households:
        for person in hh:
            if person[1] > 0 and person[1] < 6:
                #taking into account the proportional attendance by age and region
                if random.randint(0,100) < 100*kindergartenProportions[person[1]]:
                    kindergartenIndex = random.choices(population, weights)
                    kindergartenIndex = kindergartenIndex[0]
                    kindergartens[kindergartenIndex].append(person[0])

    #assigning children to schools
    primarySchools = [[] for x in range(len(schoolDistributions[0]))]
    secondarySchools = [[] for x in range(len(schoolDistributions[1]))]
    upperSecondarySchools = [[] for x in range(len(upperSecondarySchoolDistribution))]
    #households - [[[personID,age],[personID,age],...],[[personID,age],[personID,age],...],...]
    for hh in range(len(households)):
        for p in range(len(households[hh])):
            if households[hh][p][1]>=6 and households[hh][p][1]<=12:
                primarySchoolIDsForHousehold = schoolDistributions[2][householdsSchoolAffiliation[hh]]
                primarySchoolID = 0
                if len(primarySchoolIDsForHousehold)!=1:
                    assert len(primarySchoolIDsForHousehold)>0
                    population = primarySchoolIDsForHousehold
                    weights = [schoolDistributions[0][primarySchoolIDsForHousehold[x]] for x in range(len(primarySchoolIDsForHousehold))]
                    schoolIndex = random.choices(population, weights)
                    schoolIndex = schoolIndex[0]
                primarySchools[primarySchoolIDsForHousehold[primarySchoolID]].append(households[hh][p][0])
            elif households[hh][p][1]>=13 and households[hh][p][1]<=15:
                secondarySchools[householdsSchoolAffiliation[hh]].append(households[hh][p][0])
            elif households[hh][p][1]>=16 and households[hh][p][1]<=19 and sum(upperSecondarySchoolDistribution)>0:
                if random.randint(0,100)<100*secondaryEducationProportion:
                    population = range(len(upperSecondarySchoolDistribution))
                    weights = copy.deepcopy(upperSecondarySchoolDistribution)
                    schoolIndex = random.choices(population, weights)
                    schoolIndex = schoolIndex[0]
                    upperSecondarySchools[schoolIndex].append(households[hh][p][0])

    #putting ages in bins and assigning probabilities they work
    warnings.warn("WARNING! Probability that people are working at given ages is guesstimate!")
    workAgeProbability = [[0,15,0],[16,22,0.3],[23,28,0.6],[29,65,0.9],[66,70,0.3],[71,110,0]]

    #generating workforce
    workforce = []
    for i in range(len(peopleAgeList)):
        personID = peopleAgeList[i][0]
        personAge = peopleAgeList[i][1]
        for j in range(len(workAgeProbability)):
            ageIntervalLowerBound = workAgeProbability[j][0]
            ageIntervalUpperBound = workAgeProbability[j][1]
            ageIntervalWorkingProbability = workAgeProbability[j][2]
            if personAge>=ageIntervalLowerBound and personAge<=ageIntervalUpperBound:
                if random.randint(0,100)<ageIntervalWorkingProbability*100:
                    workforce.append(personID)
    random.shuffle(workforce)

    #assigning people to workplaces
    workplaces = []
    population = range(len(workplaceSizeDistribution[1]))
    weights = (workplaceSizeDistribution[1])
        # drawing random workplace size category according to distribution
        # assuming uniform distribution of workplace sizes within size categories!
    workerIterator = 0
    while 1:
        workplaceSizeCategory = random.choices(population, weights)
        workplaceSizeCategory = workplaceSizeCategory[0]
        workplaceSize = 0
        if workplaceSizeCategory == 0:
            workplaceSize = random.randint(1, 4)
        elif workplaceSizeCategory == 1:
            workplaceSize = random.randint(5, 9)
        elif workplaceSizeCategory == 2:
            workplaceSize = random.randint(10, 19)
        elif workplaceSizeCategory == 3:
            workplaceSize = random.randint(20, 49)
        elif workplaceSizeCategory == 4:
            workplaceSize = random.randint(50, 99)
        elif workplaceSizeCategory == 5:
            workplaceSize = random.randint(100, 249)
        elif workplaceSizeCategory == 6:
            #setting upper cap on workplace at 500, more or less at random
            workplaceSize = random.randint(250, 500)
        else:
            raise Exception("WorkplaceSizeCategory out of bounds!")
        workplace = []
        if workerIterator+workplaceSize>len(workforce):
            workplaceSize = len(workforce)-workerIterator
        for i in range(workplaceSize):
            workplace.append(workforce[workerIterator+i])
        workerIterator = workerIterator+workplaceSize
        workplaces.append(workplace)
        if workerIterator >= len(workforce)-1:
            break

    #assigning elderly to nursing homes
    #NB! Elderly in nursing homes are not part of households!
    #nursingHomeSizes - [size1,size2,...]
    #nursingHomePatientDistribution - [[string with age category],[number of patients in category]]
    nursingHomes = [[] for x in range(len(nursingHomeSizes))]
    population = range(len(nursingHomeSizes))
    weights = copy.deepcopy(nursingHomeSizes)
    ageWeights = copy.deepcopy(nursingHomePatientDistribution[1])
    agePopulation = range(len(nursingHomePatientDistribution[1]))
    for i in range(sum(nursingHomePatientDistribution[1])):
        #ageBins = ["Under 67 years","67-74 years","75-79 years","80-84 years","85-89 years","90 years or older"]
        personAgeCat = random.choices(agePopulation, ageWeights)
        personAgeCat = personAgeCat[0]
        personAge = 0
        if personAgeCat == 0:
            pass
            # personAge = random.randint(50,66) #seems a quite large number falls into this category, i.e. not elderly homes
        elif personAgeCat == 1:
            personAge = random.randint(67,74)
        elif personAgeCat == 2:
            personAge = random.randint(75,79)
        elif personAgeCat == 3:
            personAge = random.randint(80,84)
        elif personAgeCat == 4:
            personAge = random.randint(85,89)
        elif personAgeCat == 5:
            personAge = random.randint(90,105)
        nIndex = random.choices(population, weights)
        nIndex = nIndex[0]
        nursingHomes[nIndex].append(peopleIDs)
        peopleAgeList.append([peopleIDs,personAge])
        peopleIDs = peopleIDs+1


    # peopleAgeList - [[personID,age],...]
    outputFile = open("idAndAge_"+municipalityToGet+".txt", "w")
    for person in peopleAgeList:
        outputFile.write(str(person[0])+";"+str(person[1])+"\n")
    outputFile.close()

    outputFile = open("socialNetwork_"+municipalityToGet+".txt", "w")
    
    # households - [[[personID,age],[personID,age],...],[[personID,age],[personID,age],...],...]
    for hh in households:
        if len(hh)>0:
            householdString = ""
            for person in hh:
                householdString = householdString+";"+str(person[0])
            outputFile.write("Household"+householdString+"\n")
        # else:
        #     print("Empty household")
    # primarySchools = [[personID,personID,...],[personID,personID,...]...]
    for school in primarySchools:
        if len(school)>0:
            outputFile.write("PrimarySchool;"+';'.join([str(person) for person in school])+"\n")
        # else:
        #     print("Empty primary school")
    # secondarySchools = [[personID,personID,...],[personID,personID,...]...]
    for school in secondarySchools:
        if len(school)>0:
            outputFile.write("SecondarySchool;"+';'.join([str(person) for person in school])+"\n")
        # else:
        #     print("Empty secondary school")
    # upperSecondarySchools = [[personID,personID,...],[personID,personID,...]...]
    for school in upperSecondarySchools:
        if len(school)>0:
            outputFile.write("UpperSecondarySchool;"+';'.join([str(person) for person in school])+"\n")
        # else:
        #     print("Empty upper secondary school")
    # workplaces - [[personID,...],[personID,...],...]
    for workplace in workplaces:
        if len(workplace)>0:
            outputFile.write("Workplace;"+';'.join([str(person) for person in workplace])+"\n")
        # else:
        #     print("Empty workplace")
    # nursingHomes - [[personID,personID,...],[personID,personID,...]]
    for nursingHome in nursingHomes:
        if len(nursingHome)>0:
            outputFile.write("NursingHome;"+';'.join([str(person) for person in nursingHome])+"\n")
        # else:
        #     print("Empty nursing home")
    # kindergartens - [[personID,personID,...],[personID,personID,...]]
    for kindergarten in kindergartens:
        if len(kindergarten)>0:
            outputFile.write("Kindergarten;"+';'.join([str(person) for person in kindergarten])+"\n")
        # else:
        #     print("Empty kindergarten")
    outputFile.close()
    print("Network for "+municipalityToGet+" generated")
    print("Put "+str(len(peopleAgeList))+" people in "+str(len(households))+" households, "+str(len(kindergartens))+" kindergartens, "+str(len(primarySchools))+" primary schools, "+str(len(secondarySchools))+" lower secondary schools, "+str(len(upperSecondarySchools))+" upper secondary schools, "+str(len(workplaces))+" workplaces, and "+str(len(nursingHomes))+" nursing homes.")
    print("")

    #save in file: cliqueType;id1;id2;...
    #e.g.:
    # Household 1 2 3 4 5 6
    # Household 7 8
    # Work 1 7 11
    # Work 2, 10, 14, 15
    # School 3, 13, 19, 24

    #separate file: id;age
    #e.g.:
    # 0;14
    # 1;32
    # 2;21

    #TODO:
    #   Add hospitals
    #   Add workers in schools, kindergartens, nursing homes, hospitals
    #   School data missing for some municipalities due to outdated municipality names
    #       - Kommune (Legacy): https://data-nxr-fellestjeneste.udir.no/swagger/ui/index
    #   More data on kindergartens
    #       - https://data-nbr.udir.no/swagger/ui/index
    #   Add sanity checks (demographic distribution vs original data, etc)
    #   Find and implement better data for compositions of couples, families, sibling flocks etc.
    #   Find and implement better data for employment rates for age groups etc.
    #   Find better school data? (replace 4.5 hack) https://www.udir.no/tall-og-forskning/statistikk/statistikk-videregaende-skole/elevtall-i-videregaende-skole/elevtall-fylker-og-skoler/

# generateSocialNetworkForRegion("Moss")
# generateSocialNetworkForRegion("Holmestrand")
# generateSocialNetworkForRegion("Sandefjord")
# generateSocialNetworkForRegion("Elverum")
# generateSocialNetworkForRegion("Rendalen")
# generateSocialNetworkForRegion("Rakkestad")
# generateSocialNetworkForRegion("LÃ¸renskog")
# generateSocialNetworkForRegion("Halden")
# generateSocialNetworkForRegion("TrÃ¸gstad")
generateSocialNetworkForRegion("Oslo")
generateSocialNetworkForRegion("Bergen")
generateSocialNetworkForRegion("Stavanger")
generateSocialNetworkForRegion("TromsÃ¸")