import pandas as pd
import random
import warnings
import copy
import math
import os
import time

# # # # #
# # # # # Functions to get the different distributions from the csv files generated by croPopDat.py
# # # # #

def getAgeDistribution(queryMunicipality,dataDirName):
    #07459: Population, by sex and one-year age groups (M) 1986 - 2020
    #This function uses the above dataset from SSB found in dataDirName to return
    # "ageDistribution", the number of people at any gives age across
    # ages 0 to 105 for the given queryMunicipality as a python list
    pop_age_region_dataFrame = pd.read_csv(dataDirName+"pop_age_region.csv")
    osloAges = pop_age_region_dataFrame.loc[pop_age_region_dataFrame['region'] == queryMunicipality]
    ageDistribution = []
    for i in range(106):
        queryAge = str(i)+" years"
        if i==1:
            queryAge = "1 year"
        ageVals = osloAges.loc[osloAges['age'] == queryAge]
        ageDistribution.append(sum(ageVals['value']))
    return ageDistribution

def getHouseholdSizeDistribution(queryMunicipality,dataDirName):
    #06079: Private households and persons in private households, by size of household (per cent) (M) (UD) 2005 - 2019
    #This function uses the above dataset from SSB to return
    # "householdSizeDistribution", which is the distribution of household sizes in terms of the
    # proportion of households that contain 1, 2, 3, 4 and 5+ people in them as a python list
    household_sizes_dataFrame = pd.read_csv(dataDirName+"household_sizes.csv")
    regionHouseholds = household_sizes_dataFrame.loc[household_sizes_dataFrame['region'] == queryMunicipality]
    regionHouseholds = regionHouseholds.loc[regionHouseholds['contents'] == 'Persons in private households']
    regionHouseholds['value'].tolist()
    householdSizeDistribution = regionHouseholds['value'].tolist()
    return householdSizeDistribution

def getHouseHoldTypeDistribution(queryMunicipality,dataDirName):
    #06070: Privathusholdninger, etter husholdningstype (K) (B) 2005 - 2019
    #This function uses the above dataset from SSB to return
    #  "householdData", which is the type of household (as given in "householdTypes")
    # and the number of households of the respective types for the given municipality
    # as two lists in a nested python list ("[householdTypes,householdNumbers]")
    household_type_dataFrame = pd.read_csv(dataDirName+"household_type.csv")
    regionHouseholds = household_type_dataFrame.loc[household_type_dataFrame['region'] == queryMunicipality]
    # print(regionHouseholds)
    householdTypes = ["Living alone","Couple without resident children","Couple with small children (youngest child 0-5 years)","Couple with older children (youngest child 6-17 years)","Lone parent with small children (youngest child 0-5 years)","Lone parent with older children (youngest child 6-17 years)","One family households with adult children (youngest child 18 years and over","Two or more-family households without resident children 0-17 years","Two or more-family households with small children (youngest child 0-5 years)","Two or more-family households with older children (youngest child 6-17 years)"]
    householdNumbers = []
    for i in householdTypes:
        householdNumbers.append(sum(regionHouseholds.loc[regionHouseholds['type of household'] == i]['value']))
    assert len(householdTypes)==len(householdNumbers)
    householdData = [householdTypes,householdNumbers]
    # 0 "Living alone"
    # 1 "Couple without resident children"
    # 2 "Couple with small children (youngest child 0-5 years)"
    # 3 "Couple with older children (youngest child 6-17 years)"
    # 4 "Lone parent with small children (youngest child 0-5 years)"
    # 5 "Lone parent with older children (youngest child 6-17 years)"
    # 6 "One family households with adult children (youngest child 18 years and over"
    # 7 "Two or more-family households without resident children 0-17 years"
    # 8 "Two or more-family households with small children (youngest child 0-5 years)"
    # 9 "Two or more-family households with older children (youngest child 6-17 years)"
    ##SINGLE PARENT OR NOT IS IMPORTANT! 
    ## Living with both parents, total	
    #Children with no siblings	127 194
    #Children with siblings, total	709 612 
    #TOT = 836,806
    ## Living with one of the parents, total	
    #Children with no siblings	99 231
    #Children with siblings, total	175 450
    #TOT = 274,681‬
    ## Fractions with both/single parents
    #No siblings 0.56/0.44
    #Siblings 0.80/0.20
    #TOT 0.75/0.25
    return householdData

def getSiblingFlockSizeDistribution(dataDirName):
    #06206: Children 0-17 years, by number of siblings and the child's age 2001 - 2019
    #This function uses data from the above given dataset from SSB to calculate the proportion
    # of sibling flocks that fall in the different size categories (1, 2, 3, 4, 5, 6+).
    # Importantly, it derives this statistic, which speaks of sibling flock sizes, from data
    # on how many siblings children tend to have, and how many children tend to have siblings.
    # These proportions, as decimal fractions, are returned as 
    # "siblingFlockSizeDistribution", a python list
    siblingFlockSizeDistribution = [0.197,0.584*0.803,0.311*0.803,0.073*0.803,0.019*0.803,0.012*0.803]
    for i in range(len(siblingFlockSizeDistribution)):
        siblingFlockSizeDistribution[i] = siblingFlockSizeDistribution[i]/(1+i)
    siblingFlockSum = sum(siblingFlockSizeDistribution[1:])
    for i in range(len(siblingFlockSizeDistribution)-1):
        siblingFlockSizeDistribution[i+1] = 0.803*siblingFlockSizeDistribution[i+1]/siblingFlockSum
    assert sum(siblingFlockSizeDistribution)>0.99 and sum(siblingFlockSizeDistribution)<1.01
    return siblingFlockSizeDistribution
    
def getSecondaryEducationProportion(dataDirName):
    #08947: Pupils, apprentices, students and participants in upper secondary education, by sex, age and type of school/institution 2006 - 2019
    #This function uses data from the above SSB dataset to approximate the proportion of secondary school attendance for children and young
    # adults aged 16 to 20, which is returned as a float

    #upper_secondary_schoolers_dataFrame = pd.read_csv(dataDirName+"upper_secondary_schoolers.csv")
    #2,"Public maintained schools, total",Both sexes,16-18 years,"Pupils, apprentices, students and participants",2019,176923
    #3,"Public maintained schools, total",Both sexes,19-24 years,"Pupils, apprentices, students and participants",2019,58448
    #total number of people 16-24 in upper secondary school: 176923+58448=235371
    #total proportion of people 16-24 in upper secondary school: 235371/(32300+31684+32696+34517+34794+34159+35129+36127+36264+30722+30367+30861+32067+32019+32005+32688+33822+33822)=0.394
    #people 16-20 divided by people 16-24 in upper secondary school: 235371/(32300+31684+32696+34517+34794+30722+30367+30861+32067+32019)=0.731
    # 16,The whole country,Males,16 years,Persons,2020,32300
    # 17,The whole country,Males,17 years,Persons,2020,31684
    # 18,The whole country,Males,18 years,Persons,2020,32696
    # 19,The whole country,Males,19 years,Persons,2020,34517
    # 20,The whole country,Males,20 years,Persons,2020,34794
    # 21,The whole country,Males,21 years,Persons,2020,34159
    # 22,The whole country,Males,22 years,Persons,2020,35129
    # 23,The whole country,Males,23 years,Persons,2020,36127
    # 24,The whole country,Males,24 years,Persons,2020,36264
    # 122,The whole country,Females,16 years,Persons,2020,30722
    # 123,The whole country,Females,17 years,Persons,2020,30367
    # 124,The whole country,Females,18 years,Persons,2020,30861
    # 125,The whole country,Females,19 years,Persons,2020,32067
    # 126,The whole country,Females,20 years,Persons,2020,32019
    # 127,The whole country,Females,21 years,Persons,2020,32005
    # 128,The whole country,Females,22 years,Persons,2020,32688
    # 129,The whole country,Females,23 years,Persons,2020,33822
    # 130,The whole country,Females,24 years,Persons,2020,33822
    warnings.warn("WARNING! SECONDARY EDUCATION PROPORTION DATA IS GUESSTIMATE")
    return 0.6

def getWorkplaceSizeDistribution(queryMunicipality,dataDirName):
    #10308: Establishments, by the enterprises sector and number of employees (M) 2012 - 2020
    #This function uses the above dataset from SSB to return two python lists in a nested list: 
    # 1) the different establishment sizes from the dataset
    # 2) the number of total employees in each category of establishment in the given municipality (kommune)
    establishments_dataFrame = pd.read_csv(dataDirName+"establishments.csv")
    regionEstablishments = establishments_dataFrame.loc[establishments_dataFrame['region'] == queryMunicipality]
    employeeBins = ["1-4 employees","5-9 employees","10-19 employees","20-49 employees","50-99 employees","100 - 249 employees","250 employees and more"]
    employeeNumbers = []
    for i in employeeBins:
        employeeNumbers.append(sum(regionEstablishments.loc[regionEstablishments['number of employees'] == i]['value']))
    assert len(employeeBins) == len(employeeNumbers)
    return [employeeBins,employeeNumbers]

def getSchoolSizeDistribution(queryMunicipality,dataDirName):

    #This function uses data from the NSR (Norsk skoleregister) API and returns 
    # "[primarySchoolSizes,secondarySchoolSizes,schoolAssociations],upperSecondarySchoolDistribution"
    # where "primarySchoolSizes" and "secondarySchoolSizes" are lists of the sizes of all school groups
    # with primary and secondary school age children given as number of pupils,
    # "schoolAssociations" is a list that links any given secondary school to a set of primary schools, and
    # "upperSecondarySchoolDistribution" is a list with all the sizes of all school groups with upper secondary school age children

    #loading data
    allSchools_dataFrame = pd.read_csv(dataDirName+"allSchools.csv")
    regionSchools = allSchools_dataFrame.loc[allSchools_dataFrame['KommuneNavn'] == queryMunicipality]
    # print("len(regionSchools['KommuneNavn'])")
    if len(regionSchools['KommuneNavn']) == 0:
        print("Data for schools in "+queryMunicipality+" is missing.")
        
    lowerSchools = regionSchools.loc[regionSchools['ErGrunnSkole'] == True]
    upperSchools = regionSchools.loc[regionSchools['ErVideregaaendeSkole'] == True]
    # upperSchools.to_csv(dataDirName+'upperSchools_'+queryMunicipality+'.csv')
    # print(upperSchools)

    #converting number of pupils, school steps and employees to lists
    lowerSchoolPupilNumber = lowerSchools['Elevtall'].tolist()
    lowerSchoolStepFrom = lowerSchools['SkoleTrinnFra'].tolist()
    lowerSchoolStepTo = lowerSchools['SkoleTrinnTil'].tolist()
    lowerSchoolEmployeesFrom = lowerSchools['AnsatteFra'].tolist()
    lowerSchoolEmployeesTo = lowerSchools['AnsatteTil'].tolist()


    #converting number of pupils, school steps and employees to lists
    upperSchoolPupilNumber = upperSchools['Elevtall'].tolist()
    upperSchoolStepFrom = upperSchools['SkoleTrinnFra'].tolist()
    upperSchoolStepTo = upperSchools['SkoleTrinnTil'].tolist()
    upperSchoolEmployeesFrom = upperSchools['AnsatteFra'].tolist()
    upperSchoolEmployeesTo = upperSchools['AnsatteTil'].tolist()


    #generating lower school sizes and employee numbers

    primarySchoolSizes = []
    primarySchoolEmployees = []
    secondarySchoolSizes = []
    secondarySchoolEmployees = []

    for school in range(len(lowerSchoolPupilNumber)):
        try:
            schoolEmployees = int((lowerSchoolEmployeesFrom[school]+lowerSchoolEmployeesTo[school])/2)
            schoolPupils = int(lowerSchoolPupilNumber[school])
            if lowerSchoolStepFrom[school]==1 and lowerSchoolStepTo[school]==7:
                primarySchoolSizes.append(schoolPupils)
                primarySchoolEmployees.append(schoolEmployees)
            elif lowerSchoolStepFrom[school] == 8 and lowerSchoolStepTo[school] == 10:
                secondarySchoolSizes.append(schoolPupils)
                secondarySchoolEmployees.append(schoolEmployees)
            elif lowerSchoolStepFrom[school]==1 and lowerSchoolStepTo[school]==10:
                primarySchoolSizes.append(int(0.7*schoolPupils))
                primarySchoolEmployees.append(schoolEmployees*0.7)
                secondarySchoolSizes.append(int(0.3*schoolPupils))
                secondarySchoolEmployees.append(int(schoolEmployees*0.3))
            elif lowerSchoolStepFrom[school]==1 and lowerSchoolStepTo[school]==13:
                primarySchoolSizes.append(int(7/13*schoolPupils))
                primarySchoolEmployees.append(int(schoolEmployees*7/13))
                secondarySchoolSizes.append(int(3/13*schoolPupils))
                secondarySchoolEmployees.append(int(schoolEmployees*3/13))
            elif lowerSchoolStepFrom[school]==1 and lowerSchoolStepTo[school]==12:
                primarySchoolSizes.append(int(7/12*schoolPupils))
                primarySchoolEmployees.append(int(schoolEmployees*7/12))
                secondarySchoolSizes.append(int(3/12*schoolPupils))
                secondarySchoolEmployees.append(int(schoolEmployees*3/12))
            elif lowerSchoolStepFrom[school]==8 and lowerSchoolStepTo[school]==13:
                secondarySchoolSizes.append(int(0.5*schoolPupils))
                secondarySchoolEmployees.append(int(schoolEmployees*0.5))
            elif lowerSchoolStepFrom[school]==1 and lowerSchoolStepTo[school]==6:
                primarySchoolSizes.append(schoolPupils)
                primarySchoolEmployees.append(schoolEmployees)
        # else:
            # print("lowerSchoolStepFrom[school]: "+str(lowerSchoolStepFrom[school])+", lowerSchoolStepTo[school]: "+str(lowerSchoolStepTo[school])+", lowerSchoolPupilNumber[school]: "+str(lowerSchoolPupilNumber[school]))
        except:
            print("Couldn't generate school data for lower school #"+str(school)+" in "+queryMunicipality+" due to nan values")

    #generating upper school sizes and employee numbers
    
    upperSecondarySchoolDistribution = []
    upperSecondarySchoolEmployees = []
    
    for school in range(len(upperSchoolPupilNumber)):
        try:
            schoolEmployees = int((upperSchoolEmployeesFrom[school]+upperSchoolEmployeesTo[school])/2)
            #numbers are missing for many upper secondary schools
            if math.isnan(upperSchoolPupilNumber[school]):
                #there appears to be numbers for employees for a lot more, and there appears to be roughly (read: sketchy approximation) 4.5 students per employee
                sketchyApproximation = upperSchoolEmployeesTo[school]*4.5
                if math.isnan(sketchyApproximation):
                    sketchyApproximation = 0
                upperSchoolPupilNumber[school] = int(sketchyApproximation)
            if upperSchoolStepFrom[school] == 11 and upperSchoolStepTo[school] == 13:
                upperSecondarySchoolDistribution.append(upperSchoolPupilNumber[school])
                upperSecondarySchoolEmployees.append(schoolEmployees)
            elif upperSchoolStepFrom[school] == 8 and upperSchoolStepTo[school] == 13:
                upperSecondarySchoolDistribution.append(int(0.5*upperSchoolPupilNumber[school]))
                upperSecondarySchoolEmployees.append(int(schoolEmployees*0.5))
            elif upperSchoolStepFrom[school] == 1 and upperSchoolStepTo[school] == 13:
                upperSecondarySchoolDistribution.append(int(3/13*upperSchoolPupilNumber[school]))
                upperSecondarySchoolEmployees.append(int(schoolEmployees*3/13))
            elif upperSchoolStepFrom[school] == 1 and upperSchoolStepTo[school] == 12:
                upperSecondarySchoolDistribution.append(int(2/12*upperSchoolPupilNumber[school]))
                upperSecondarySchoolEmployees.append(int(schoolEmployees*2/12))
        except:
            print("Couldn't generate school data for upper school #"+str(school)+" in "+queryMunicipality+" due to nan values")
        # else:
        #     print("upperSchoolStepFrom[school]: "+str(upperSchoolStepFrom[school])+", upperSchoolStepTo[school]: "+str(upperSchoolStepTo[school])+", upperSchoolPupilNumber[school]: "+str(upperSchoolPupilNumber[school]))

    #associating primary schools with lower secondary schools, generating implicit geographical linkage
    if not len(primarySchoolSizes)>len(secondarySchoolSizes):
        print("primarySchoolSizes:")
        print(primarySchoolSizes)
        print("secondarySchoolSizes:")
        print(secondarySchoolSizes)
    assert(len(primarySchoolSizes)>len(secondarySchoolSizes))
    primarySchoolSizes.sort(reverse = True)
    secondarySchoolSizes.sort(reverse = True)
    
    schoolAssociations = [[] for x in range(len(secondarySchoolSizes))] #linking each secondary schools to set of primary schools. index is secondary school, values are lists of primary schools

    #iteratively assigning the biggest primary school to the secondary school with the largest proportional amount of spaces left
    secondarySchoolSlotsVacant = copy.deepcopy(secondarySchoolSizes)
    for school in range(len(primarySchoolSizes)):
        schoolIndex = secondarySchoolSlotsVacant.index(max(secondarySchoolSlotsVacant))
        schoolAssociations[schoolIndex].append(school)
        secondarySchoolSlotsVacant[schoolIndex] = secondarySchoolSlotsVacant[schoolIndex]-int(3*primarySchoolSizes[school])

    schoolEmployees = [primarySchoolEmployees,secondarySchoolEmployees,upperSecondarySchoolEmployees]
    return [primarySchoolSizes,secondarySchoolSizes,schoolAssociations],upperSecondarySchoolDistribution,schoolEmployees #schoolAssocations has secondary school ID as index and primary school IDs as value

def getElderlyHomeDistribution(queryMunicipality,queryCounty,dataDirName):
    #This function uses the data set #11933: Care institutions - rooms, by region, contents and year (M)
    # from SSB and returns "nursingHomeSizes,[ageBins,ageNumbers]", where "nursingHomeSizes" is 
    # a list of the size of all nursing rooms in the municipality, "ageBins"
    # is a list of strings describing the age groups in nursing homes, and "ageNumbers" is a list of
    # all the patients in the corresponding ageBin in nursing homes in the given municipality
    
    #09929: Nursing and care institutions and beds, by ownership (C) 2009 - 2018

    # nursing_spots_dataFrame = pd.read_csv(dataDirName+"nursing_spots.csv")

    #11933: Care institutions - rooms, by region, contents and year (M)
    nursingHomeRooms_dataFrame = pd.read_csv(dataDirName+"nursingHomeRooms.csv")

    #generating nursing home size distribution by dividing the number of beds by the number of institutions and assuming some kind of middle-heavy distribution
    #generating nursing homes number by dividing number of patients by average nursing home size
    #distribution below is "weighting for each bin of 10"

    regionNursingHomeRooms = nursingHomeRooms_dataFrame[nursingHomeRooms_dataFrame['region'] == queryMunicipality]
    numberOfRooms = sum(pd.to_numeric(regionNursingHomeRooms.loc[regionNursingHomeRooms['contents'] == "Rooms, total (number)"]['value']))

    # regionNursingSpots = nursing_spots_dataFrame[nursing_spots_dataFrame['region'].str.contains(queryCounty)]
    # regionNursingSpots = regionNursingSpots[regionNursingSpots['ownership'].str.contains("total")]
    # numberOfBeds = sum(regionNursingSpots.loc[regionNursingSpots['contents'] == "Beds"]['value'])
    # numberOfInstitutions = sum(regionNursingSpots.loc[regionNursingSpots['contents'] == "Institutions"]['value'])
    
    # meanNursingHomeSize = numberOfBeds/numberOfInstitutions

    #setting mean nursing home size to 40; it's 50 for Oslo, assuming smaller average
    meanNursingHomeSize = 40
    if math.isnan(numberOfRooms):
        numberOfRooms = 0
    numberOfInstitutions = int(numberOfRooms/meanNursingHomeSize)
    if numberOfInstitutions == 0 and numberOfRooms>0:
        numberOfInstitutions = 1
    nursingHomeSizes = [meanNursingHomeSize for x in range(numberOfInstitutions)]

    #04469: Bebuarar i bustader kommunen disponerer til pleie- og omsorgsformål, etter alder (K) 2002 - 2018
    nursing_patients_dataFrame = pd.read_csv(dataDirName+"nursing_patients.csv")
    regionNursingHomes = nursing_patients_dataFrame.loc[nursing_patients_dataFrame['region'] == queryMunicipality]
    regionNursingHomes = regionNursingHomes.loc[nursing_patients_dataFrame['contents'] == 'Residents in dwellings']
    ageBins = ["Under 67 years","67-74 years","75-79 years","80-84 years","85-89 years","90 years or older"]
    ageNumbers = []
    for i in ageBins:
        numberAtAge = sum(regionNursingHomes.loc[regionNursingHomes['age'].isin([i])]['value'])
        if math.isnan(numberAtAge):
            print("Nursing home resident information unavailable! Default distribution assumed")
            meanAgeGroupSize = int(numberOfRooms/len(ageBins))
            ageGroupWeights = [0.5,0.5,0.8,1.2,1.5,1.5]
            assert sum(ageGroupWeights)/len(ageGroupWeights) == 1
            ageNumbers = [int(meanAgeGroupSize*ageGroupWeights[x]) for x in range(len(ageBins))]
            break
        else:
            ageNumbers.append(int(numberAtAge))
    assert len(ageBins) == len(ageNumbers)

    # print("numberOfRooms: "+str(numberOfRooms)+", total patients: "+str(sum(ageNumbers)))
    # print("Age distribution: u67: "+str(ageNumbers[0])+", 67-74: "+str(ageNumbers[1])+", 75-79: "+str(ageNumbers[2])+", 80-84: "+str(ageNumbers[3])+", 85-89: "+str(ageNumbers[4])+", 90+: "+str(ageNumbers[5]))

    # #determining number of nursing homes
    # numberOfNursingHomes = int(sum(ageNumbers)/meanNursingHomeSize)
    # #generating nursing homes
    # population = range(len(nursingHomeSizeDistribution))
    # weights = copy.deepcopy(nursingHomeSizeDistribution)
    # nursingHomeSizes = []
    # for i in range(numberOfNursingHomes):
    #     nursingHomeSize = random.choices(population, weights)
    #     nursingHomeSize = nursingHomeSize[0]
    #     nursingHomeSizes.append(nursingHomeSize)

    return nursingHomeSizes,[ageBins,ageNumbers]

def getKindergartenDistribution(queryMunicipality,dataDirName):

    #This function integrates the 3 datasets from SSB given below to return
    # "kindergartenSizes,kindergartenProportions", where "kindergartenSizes"
    # is a list of all the kinder gartens' sizes in the given municipality,
    # while "kindergartenProportions" is the proportion of children at a given
    # age that attend kindergarten
    
    #   loading relevant data

    #09220: Kindergartens, by ownership (M) 1987 - 2019
    kids_in_kindergartens_dataFrame = pd.read_csv(dataDirName+'kindergartenNumbers.csv')
    kindergartensRegion = kids_in_kindergartens_dataFrame.loc[kids_in_kindergartens_dataFrame['region'] == queryMunicipality]
    
    #09169: Barn i barnehager, etter region, barnehagetype, statistikkvariabel og år
    kindergartens_in_places = pd.read_csv(dataDirName+'kidsInKindergartens.csv')
    kindergartenKidsRegion = kindergartens_in_places.loc[kindergartens_in_places['region'] == queryMunicipality]

    #12562: Selected key figures kindergartens, by region, contents and year (M)
    kinderGartenAttendanceAndPersonnel = pd.read_csv(dataDirName+'kinderGartenAttendanceAndPersonnel.csv')
    kinderGartenAttendanceAndPersonnelRegion = kinderGartenAttendanceAndPersonnel.loc[kinderGartenAttendanceAndPersonnel['region'] == queryMunicipality]
    #"Percentage of 1-2 year-olds in kindergarten (per cent)", "Percentage of 3-5 year-olds in kindergarten (per cent)"
    smallKidsRates = sum(kinderGartenAttendanceAndPersonnelRegion.loc[kinderGartenAttendanceAndPersonnelRegion['contents'] == "Percentage of 1-2 year-olds in kindergarten (per cent)"]['value'])
    bigKidsRates = sum(kinderGartenAttendanceAndPersonnelRegion.loc[kinderGartenAttendanceAndPersonnelRegion['contents'] == "Percentage of 3-5 year-olds in kindergarten (per cent)"]['value'])


    ageGroups = ["0 years","1 year","2 years","3 years","4 years","5 years","6 years"]
    numberOfKidsPerYear = [sum(kindergartenKidsRegion.loc[kindergartenKidsRegion['age'] == ageGroups[i]]['value']) for i in range(7)]
    numberOfKids = sum(numberOfKidsPerYear)

    numberOfKindergartens = sum(kindergartensRegion['value'])

    #assuming (somewhat naively) homogeneous size of kindergartens in lieu of better data
    meanKindergartenSize = int(numberOfKids/numberOfKindergartens)
    
    kindergartenSizes = [meanKindergartenSize for x in range(numberOfKindergartens)]
    kindergartenProportions = [0]+[smallKidsRates/100 for x in range(2)]+[bigKidsRates/100 for x in range(3)]

    return kindergartenSizes,kindergartenProportions

def getCommuteData(queryMunicipality,dataDirName):

    #This function...
    
    #   loading relevant data

    #03321: Employed persons (aged 15-74) per 4th quarter, by municipality of work, municipality of residence, contents and year
    commuting_dataFrame = pd.read_csv(dataDirName+'municipalityResidenceEmployment.csv')
    if queryMunicipality is "Oslo":
        queryMunicipality = "Oslo municipality"
    else:
        queryMunicipality = queryMunicipality+" (-2019)"

    commutersFromRegion = commuting_dataFrame.loc[commuting_dataFrame['municipality of residence'] == queryMunicipality]
    commutersFromRegion = commutersFromRegion.loc[commutersFromRegion['municipality of work'] != queryMunicipality]
    originRegionList = commutersFromRegion['municipality of work'].tolist()
    originRegionNumbers = commutersFromRegion['value'].tolist()
    for i in range(len(originRegionList)):
        originRegion = originRegionList[i].split(" ")
        if len(originRegion)>1:
            originRegion = originRegion[0]
            originRegionList[i] = originRegion
    commuterEmploymentPlaces = [originRegionList,originRegionNumbers]

    commutersToRegion = commuting_dataFrame.loc[commuting_dataFrame['municipality of work'] == queryMunicipality]
    commutersToRegion = commutersToRegion.loc[commutersToRegion['municipality of residence'] != queryMunicipality]
    targetRegionList = commutersToRegion['municipality of residence'].tolist()
    targetRegionNumbers = commutersToRegion['value'].tolist()
    for i in range(len(targetRegionList)):
        targetRegion = targetRegionList[i].split(" ")
        if len(targetRegion)>1:
            targetRegion = targetRegion[0]
            targetRegionList[i] = targetRegion
    commuterHomePlaces = [targetRegionList,targetRegionNumbers]

    return commuterEmploymentPlaces,commuterHomePlaces

def getWorkAgeProbability(queryMunicipality,dataDirName):

    #This function...
    
    #   loading relevant data

    #06445: Employed persons, by place of residence, sex and age (per cent). 4th quarter (M) 2005 - 2019
    employmentRate_dataFrame = pd.read_csv(dataDirName+'employementRate.csv')
    # if queryMunicipality is "Oslo":
    #     queryMunicipality = "Oslo municipality"
    # else:
    #     queryMunicipality = queryMunicipality+" (-2019)"

    employmentRateForRegion = employmentRate_dataFrame.loc[employmentRate_dataFrame['region'] == queryMunicipality]
    employmentRateForRegion = employmentRateForRegion.loc[employmentRateForRegion['sex'] == "Both sexes"]
    ageGroups = employmentRateForRegion['age'].tolist()
    ageNumbers = employmentRateForRegion['value'].tolist()

    assert(ageGroups[0] == "15-74 years")
    assert(ageGroups[1] == "15-19 years")
    assert(ageGroups[-1] == "67-74 years")

    if sum(ageNumbers) == 0:
        # setting to national average as default if no data is available: 67.1,35.6,64,80,82.4,67.4,18.8
        print("No employment rate by age available for "+queryMunicipality+", assuming national average")
        ageNumbers = [67.1,35.6,64,80,82.4,67.4,18.8]
    
    workAgeProbability = [[0,14,0],[15,19,ageNumbers[1]],[20,24,ageNumbers[2]],[25,39,ageNumbers[3]],[40,54,ageNumbers[4]],[55,66,ageNumbers[5]],[67,74,ageNumbers[6]],[74,110,0]]
    return workAgeProbability


# Function for building social network

def generateSocialNetworkForRegion(municipalityToGet):

    #This function integrates the data from all the other functions
    # to generate the actual social network linking people into
    # cliques, such as households, workplaces, schools, etc.

    print("Generating network for "+municipalityToGet)

    dataDirName = os.path.dirname(__file__)
    dataDirName = dataDirName+"/populationData/"
    
    #since some data only exists with county (fylke) resolution, and not municipality (kommune) resolution,
    # a conversion is required:
    countyToGet = "Oslo"
    if municipalityToGet != "Oslo":
        county_municipality_table = pd.read_csv(dataDirName+"fylke_kommune_oldnew.txt",delimiter = "\t")
        municipalityList = county_municipality_table['Kommune 2019'].tolist()
        countyList = county_municipality_table['Fylke 2019'].tolist()
        for i in range(len(municipalityList)):
            if municipalityToGet.upper() in municipalityList[i]:
                countyToGet = countyList[i]
                break
        countyToGet = countyToGet.split()
        if len(countyToGet)>1:
            countyToGet = countyToGet[1]
        countyToGet = countyToGet.lower()
        countyToGet = countyToGet.capitalize()

    #people of different ages, index is age, value is number of people
    #Dataset from SSB: "07459: Population, by sex and one-year age groups (M) 1986 - 2020"
    ageDistribution = getAgeDistribution(municipalityToGet,dataDirName)

    print("Age distribution: 67-74: "+str(sum(ageDistribution[67:75]))+", 75-79: "+str(sum(ageDistribution[75:80]))+", 80-84: "+str(sum(ageDistribution[80:85]))+", 85-89: "+str(sum(ageDistribution[85:90]))+", 90+: "+str(sum(ageDistribution[90:])))

    #distribution of household sizes, index+1 is number of people, value is proportion
    #Dataset from SSB: "06079: Private households and persons in private households, by size of household (per cent) (M) (UD) 2005 - 2019"
    householdSizeDistribution = getHouseholdSizeDistribution(countyToGet,dataDirName)

    #distribtion of households: 2 parents, single parents, number of children distribution for each. age?
    #Dataset from SSB: "#06070: Privathusholdninger, etter husholdningstype (K) (B) 2005 - 2019"
    householdTypeDistribution = getHouseHoldTypeDistribution(municipalityToGet,dataDirName)
    #removing two or more-family households with children due to uncertainty around how to integrate data
    householdTypeDistribution[0] = householdTypeDistribution[0][0:8]
    householdTypeDistribution[1] = householdTypeDistribution[1][0:8]

    #distribution on number of siblings in flock
    #Dataset from SSB: "#06206: Children 0-17 years, by number of siblings and the child's age 2001 - 2019"
    siblingFlockSizeDistribution = getSiblingFlockSizeDistribution(dataDirName)

    #proportion of 16-20 YO in upper secondary education
    #Dataset from SSB: "#08947: Pupils, apprentices, students and participants in upper secondary education, by sex, age and type of school/institution 2006 - 2019"
    secondaryEducationProportion = getSecondaryEducationProportion(dataDirName)

    #distribution of workplace sizes
    #Dataset from SSB: "#10308: Establishments, by the enterprises sector and number of employees (M) 2012 - 2020"
    workplaceSizeDistribution = getWorkplaceSizeDistribution(municipalityToGet,dataDirName)

    #distribution of school sizes and types
    # schoolDistributions - [primarySchoolSizes,secondarySchoolSizes,schoolAssociations]
    # schoolAssocations has secondary school ID as index and primary school IDs as value
    # upperSecondarySchoolDistribution - [schoolSize1,schoolSize2,...]
    #Dataset from NSR API: "https://data-nsr.udir.no/"
    schoolDistributions,upperSecondarySchoolDistribution,schoolEmployees = getSchoolSizeDistribution(municipalityToGet,dataDirName)

    #distribution of elderly home sizes and patient number distribution by age
    #Datasets from SSB:
        # "#09929: Nursing and care institutions and beds, by ownership (C) 2009 - 2018"
        # "#04469: Bebuarar i bustader kommunen disponerer til pleie- og omsorgsformål, etter alder (K) 2002 - 2018"
        # "#11933: Care institutions - rooms, by region, contents and year"
    nursingHomeSizes,nursingHomePatientDistribution = getElderlyHomeDistribution(municipalityToGet,countyToGet,dataDirName)

    #distribution of kindergartens and kindergarten slots
    #Datasets from SSB:
        # "#09220: Kindergartens, by ownership (M) 1987 - 2019"
        # "#09169: Barn i barnehager, etter region, barnehagetype, statistikkvariabel og år"
        # "#12562: Selected key figures kindergartens, by region, contents and year"
    kindergartenSizes,kindergartenProportions = getKindergartenDistribution(municipalityToGet,dataDirName)

    #distribution of number of commuters by work municipality (commuterEmploymentPlaces [homeRegionList,homeRegionNumbers])
    # and number commuters by home municipality (commuterHomePlaces [targetRegionList,targetRegionNumbers])
    commuterEmploymentPlaces,commuterHomePlaces = getCommuteData(municipalityToGet,dataDirName)

    #distribution of working probability by age
    workAgeProbability = getWorkAgeProbability(municipalityToGet,dataDirName)

    # # # # #
    # # # # # Building households
    # # # # #

    #finding total numbers of households, adults and children
    numberHouseholds = sum(householdTypeDistribution[1])
    numberUnassignedAdults = sum(ageDistribution[18:])
    numberUnassignedChildren = sum(ageDistribution[0:18])

    #finding age probability distribution
    ageProbDist = [x/(numberUnassignedAdults+numberUnassignedChildren) for x in ageDistribution]

    assert numberUnassignedAdults + numberUnassignedChildren == sum(ageDistribution)

    #generating households

    peopleAgeList = []
    householdPeopleList = []

    households = [] #id, age
    peopleIDs = 1
    householdsPicked = [0 for x in range(10)]
    for i in range(numberHouseholds):
        population = [x for x in range(len(householdTypeDistribution[0]))]
        weights = copy.deepcopy(householdTypeDistribution[1])
        householdType = random.choices(population, weights)
        householdType = householdType[0]
        age = 0
        household = []
        if householdType == 0: #Living alone
            householdsPicked[0] = householdsPicked[0]+1
            population = range(len(ageDistribution))
            weights = copy.deepcopy(ageDistribution)
            for j in range(len(ageDistribution)):
                #assuming people 19-30 are 1/3 as likely to live alone
                if j>=19 and j<=30:
                    weights[j] = weights[j]*(1/3)
                #assuming people under 18 don't live alone
                if j<=18:
                    weights[j] = weights[j]*0
            age = random.choices(population, weights)
            age = age[0]
            household.append([peopleIDs,age])
            peopleIDs = peopleIDs+1
        elif householdType == 1: #Couple without resident children
            householdsPicked[1] = householdsPicked[1]+1
            population = range(len(ageDistribution))
            weights = copy.deepcopy(ageDistribution)
            for j in range(len(ageDistribution)):
                #assuming people 30-50 are 1/3 as likely to be childless
                if j>=30 and j<=50:
                    weights[j] = weights[j]*(1/3)
                #assuming people under 18 don't live as couples
                if j<=18:
                    weights[j] = weights[j]*0
            for j in range(2):
                age = random.choices(population, weights)
                age = age[0]
                household.append([peopleIDs,age])
                peopleIDs = peopleIDs+1
        elif householdType == 2: #Couple with small children (youngest child 0-5 years)
            householdsPicked[2] = householdsPicked[2]+1
            population = range(len(ageDistribution))
            weights = copy.deepcopy(ageDistribution)
            for j in range(len(ageDistribution)):
                #assuming people under 18 and over 60 don't have small children
                if j<=18 or j>=50:
                    weights[j] = weights[j]*0
                #assuming people 30-45 are 2x as likely to have small children
                if j>=30 and j<=45:
                    weights[j] = weights[j]*2
            #parents' age are assumed to be uncorrelated
            for j in range(2):
                age = random.choices(population, weights)
                age = age[0]
                household.append([peopleIDs,age])
                peopleIDs = peopleIDs+1
            #sibling flock size is assumed to be selected from standard distribution
            population = range(len(siblingFlockSizeDistribution))
            weights = copy.deepcopy(siblingFlockSizeDistribution)
            flockSize = random.choices(population, weights)
            flockSize = flockSize[0]+1 #adding +1 since index 0 is size 1
            for j in range(flockSize):
                population = range(len(ageDistribution[0:19]))
                weights = ageDistribution[0:19]
                #assuming flocks with younger children are more likely to have younger children
                for i in range(len(weights)):
                    if i<6:
                        weights[i] = weights[i]*4
                age = random.choices(population, weights)
                age = age[0]
                household.append([peopleIDs,age])
                peopleIDs = peopleIDs+1
        elif householdType == 3: #Couple with older children (youngest child 6-17 years)
            householdsPicked[3] = householdsPicked[3]+1
            population = range(len(ageDistribution))
            weights = copy.deepcopy(ageDistribution)
            for j in range(len(ageDistribution)):
                #assuming people under 25 and over 65 don't have older children
                if j<=25 or j>=65:
                    weights[j] = weights[j]*0
                #assuming people 30-50 are 1.5 as likely to have children
                if j>=30 and j<=50:
                    weights[j] = weights[j]*1.5
            #parents' age are assumed to be uncorrelated
            for j in range(2):
                age = random.choices(population, weights)
                age = age[0]
                household.append([peopleIDs,age])
                peopleIDs = peopleIDs+1
            #sibling flock size is assumed to be between 1 and 3
            population = range(len(siblingFlockSizeDistribution[0:4]))
            weights = copy.deepcopy(siblingFlockSizeDistribution[0:4])
            flockSize = random.choices(population, weights)
            flockSize = flockSize[0]+1 #adding +1 since index 0 is size 1
            for j in range(flockSize):
                population = [x for x in range(6,19)]
                weights = ageDistribution[6:19]
                age = random.choices(population, weights)
                age = age[0]
                household.append([peopleIDs,age])
                peopleIDs = peopleIDs+1
        elif householdType == 4: #Lone parent with small children (youngest child 0-5 years)
            householdsPicked[4] = householdsPicked[4]+1
            population = range(len(ageDistribution))
            weights = copy.deepcopy(ageDistribution)
            for j in range(len(ageDistribution)):
                #assuming people under 18 and over 60 don't have small children
                if j<=18 or j>=50:
                    weights[j] = weights[j]*0
                #assuming people 30-45 are 2x as likely to have small children
                if j>=30 and j<=45:
                    weights[j] = weights[j]*2
            age = random.choices(population, weights)
            age = age[0]
            household.append([peopleIDs,age])
            peopleIDs = peopleIDs+1
            #sibling flock size is considered 1/4 as likely to be larger than 1
            population = range(len(siblingFlockSizeDistribution))
            weights = copy.deepcopy(siblingFlockSizeDistribution)
            for j in range(len(siblingFlockSizeDistribution)):
                if j>0:
                    weights[j] = weights[j]*(1/4)
            flockSize = random.choices(population, weights)
            flockSize = flockSize[0]+1 #adding +1 since index 0 is size 1
            for j in range(flockSize):
                population = range(len(ageDistribution[0:18]))
                weights = copy.deepcopy(ageDistribution[0:18])
                #assuming flocks with younger children are more likely to have younger children
                for i in range(len(weights)):
                    if i<6:
                        weights[i] = weights[i]*4
                age = random.choices(population, weights)
                age = age[0]
                household.append([peopleIDs,age])
                peopleIDs = peopleIDs+1
        elif householdType == 5: #Lone parent with older children (youngest child 6-17 years)
            householdsPicked[5] = householdsPicked[5]+1
            population = range(len(ageDistribution))
            weights = copy.deepcopy(ageDistribution)
            for j in range(len(ageDistribution)):
                #assuming people under 25 and over 65 don't have older children
                if j<=25 or j>=65:
                    weights[j] = weights[j]*0
                #assuming people 30-50 are 1.5 as likely to have children
                if j>=30 and j<=50:
                    weights[j] = weights[j]*1.5
            age = random.choices(population, weights)
            age = age[0]
            household.append([peopleIDs,age])
            peopleIDs = peopleIDs+1
            #sibling flock size is assumed to be between 1 and 3, and to be 1/4 as likely to be larger than 1
            population = range(len(siblingFlockSizeDistribution[0:4]))
            weights = copy.deepcopy(siblingFlockSizeDistribution[0:4])
            for j in range(len(siblingFlockSizeDistribution[0:4])):
                if j>0:
                    weights[j] = weights[j]*(1/4)
            flockSize = random.choices(population, weights) #adding +1 since index 0 is size 1
            flockSize = flockSize[0]+1 #adding +1 since index 0 is size 1
            for j in range(flockSize):
                population = range(6,19)
                weights = copy.deepcopy(ageDistribution[6:19])
                age = random.choices(population, weights)
                age = age[0]
                household.append([peopleIDs,age])
                peopleIDs = peopleIDs+1
        elif householdType == 6: #One family households with adult children (youngest child 18 years and over
            householdsPicked[6] = householdsPicked[6]+1
            population = range(len(ageDistribution))
            weights = copy.deepcopy(ageDistribution)
            #assuming people with moved-out children are 45 or up
            for j in range(len(ageDistribution)):
                if j<=45:
                    weights[j] = weights[j]*0
            for j in range(2):
                age = random.choices(population, weights)
                age = age[0]
                household.append([peopleIDs,age])
                peopleIDs = peopleIDs+1
        elif householdType == 7: #Two or more-family households without resident children 0-17 years
            householdsPicked[7] = householdsPicked[7]+1
            population = range(len(ageDistribution))
            weights = copy.deepcopy(ageDistribution)
            for j in range(len(ageDistribution)):
                if j<19: #asserting adults-only
                    weights[j] = weights[j]*0
                if j>28: #assuming multi-family households are mostly flatshares
                    weights[j] = weights[j]*0.1
            numberOfPeople = random.randint(2,6) #assuming these households have somewhere between 2 and 6 people
            for j in range(numberOfPeople):
                age = random.choices(population, weights)
                age = age[0]
                household.append([peopleIDs,age])
                peopleIDs = peopleIDs+1
        else:
            raise Exception("Missing case in household type selection")
        # elif householdType == 7:
        #     #Two or more-family households without resident children 0-17 years
        # elif householdType == 8:
        #     #Two or more-family households with small children (youngest child 0-5 years)
        # elif householdType == 9:
        #     #Two or more-family households with older children (youngest child 6-17 years)'
        for person in household:
            peopleAgeList.append(person)
            householdPeopleList.append([i,person[0]])
        households.append(household)

    #assigning households to lower secondary schools
    #schoolDistributions - [primarySchoolSizes,secondarySchoolSizes,schoolAssociations] #schoolAssocations has secondary school ID as index and primary school IDs as value
    householdsSchoolAffiliation = []
    population = range(len(schoolDistributions[1]))
    weights = copy.deepcopy(schoolDistributions[1])
    for i in range(numberHouseholds):
        schoolIndex = random.choices(population, weights)
        schoolIndex = schoolIndex[0]
        householdsSchoolAffiliation.append(schoolIndex)

    #assigning children to kindergartens
    #assigning kids to kindergartens randomly according to size weights and age attendance proportion
    #kindergartenSizes - [size1, size2, ...]
    kindergartens = [[] for x in range(len(kindergartenSizes))]
    population = range(len(kindergartens))
    weights = copy.deepcopy(kindergartenSizes)
    for hh in households:
        #assigning household to kindergarten
        kindergartenIndex = random.choices(population, weights)
        kindergartenIndex = kindergartenIndex[0]
        kindergartenAttendants = []
        for person in hh:
            if person[1] > 0 and person[1] < 6:
                personId = person[0]
                personAge = person[1]
                kindergartenAttendants.append([personId,personAge,0])
                #taking into account the proportional attendance by age and region
                if random.randint(0,100) < 100*kindergartenProportions[personAge]:
                    kindergartenAttendants[-1][2] = 1
                else:
                    #making sure that younger siblings of kindergarten non-attendants do also not attend kindergarten
                    for attendant in kindergartenAttendants:
                        if attendant[1]<personAge:
                            attendant[2] = 0
        for attendant in kindergartenAttendants:
            if attendant[2] == 1:
                kindergartens[kindergartenIndex].append(attendant[0])

    #assigning children to schools
    primarySchools = [[] for x in range(len(schoolDistributions[0]))]
    secondarySchools = [[] for x in range(len(schoolDistributions[1]))]
    upperSecondarySchools = [[] for x in range(len(upperSecondarySchoolDistribution))]
    #households - [[[personID,age],[personID,age],...],[[personID,age],[personID,age],...],...]
    for hh in range(len(households)):
        for p in range(len(households[hh])):
            if households[hh][p][1]>=6 and households[hh][p][1]<=12:
                primarySchoolIDsForHousehold = schoolDistributions[2][householdsSchoolAffiliation[hh]]
                primarySchoolID = 0
                if len(primarySchoolIDsForHousehold)!=1:
                    assert len(primarySchoolIDsForHousehold)>0
                    population = primarySchoolIDsForHousehold
                    weights = [schoolDistributions[0][primarySchoolIDsForHousehold[x]] for x in range(len(primarySchoolIDsForHousehold))]
                    schoolIndex = random.choices(population, weights)
                    schoolIndex = schoolIndex[0]
                primarySchools[primarySchoolIDsForHousehold[primarySchoolID]].append(households[hh][p][0])
            elif households[hh][p][1]>=13 and households[hh][p][1]<=15:
                secondarySchools[householdsSchoolAffiliation[hh]].append(households[hh][p][0])
            elif households[hh][p][1]>=16 and households[hh][p][1]<=19 and sum(upperSecondarySchoolDistribution)>0:
                if random.randint(0,100)<100*secondaryEducationProportion:
                    population = range(len(upperSecondarySchoolDistribution))
                    weights = copy.deepcopy(upperSecondarySchoolDistribution)
                    schoolIndex = random.choices(population, weights)
                    schoolIndex = schoolIndex[0]
                    upperSecondarySchools[schoolIndex].append(households[hh][p][0])

    #putting ages in bins and assigning probabilities they work
    # warnings.warn("WARNING! Probability that people are working at given ages is guesstimate!")
    # workAgeProbability = [[0,15,0],[16,22,30],[23,28,60],[29,65,90],[66,70,30],[71,110,0]]

    #generating workforce
    workforce = []
    for i in range(len(peopleAgeList)):
        personID = peopleAgeList[i][0]
        personAge = peopleAgeList[i][1]
        for j in range(len(workAgeProbability)):
            ageIntervalLowerBound = workAgeProbability[j][0]
            ageIntervalUpperBound = workAgeProbability[j][1]
            ageIntervalWorkingProbability = workAgeProbability[j][2]
            if personAge>=ageIntervalLowerBound and personAge<=ageIntervalUpperBound:
                if random.randint(0,100)<ageIntervalWorkingProbability:
                    workforce.append(personID)
    random.shuffle(workforce) # this is important! or else people are bunched into workplaces by household etc.

    #assigning elderly to nursing homes
    #Elderly in nursing homes are not part of households!
    #This code is run after generating the workforce so that no further sorting will be necessary
    #nursingHomeSizes - [size1,size2,...]
    #nursingHomePatientDistribution - [[string with age category],[number of patients in category]]
    nursingHomes = [[] for x in range(len(nursingHomeSizes))]
    population = range(len(nursingHomeSizes))
    weights = copy.deepcopy(nursingHomeSizes)
    ageWeights = copy.deepcopy(nursingHomePatientDistribution[1])
    agePopulation = range(len(nursingHomePatientDistribution[1]))
    for i in range(sum(nursingHomePatientDistribution[1])):
        #ageBins = ["Under 67 years","67-74 years","75-79 years","80-84 years","85-89 years","90 years or older"]
        personAgeCat = random.choices(agePopulation, ageWeights)
        personAgeCat = personAgeCat[0]
        personAge = 0
        if personAgeCat == 0:
            pass
            # personAge = random.randint(50,66) #seems a quite large number falls into this category, i.e. not elderly homes
        elif personAgeCat == 1:
            personAge = random.randint(67,74)
        elif personAgeCat == 2:
            personAge = random.randint(75,79)
        elif personAgeCat == 3:
            personAge = random.randint(80,84)
        elif personAgeCat == 4:
            personAge = random.randint(85,89)
        elif personAgeCat == 5:
            personAge = random.randint(90,105)
        nIndex = random.choices(population, weights)
        nIndex = nIndex[0]
        nursingHomes[nIndex].append(peopleIDs)
        peopleAgeList.append([peopleIDs,personAge])
        peopleIDs = peopleIDs+1

    #setting up workplaces
    workplaces = []
    workerIterator = 0

    #assigning people to commuter OUT workplaces

    #commuterEmploymentPlaces [homeRegionList,homeRegionNumbers]
    commuterEmployments = [] #[[place,[peopleIds]],[place,[peopleIds]],...]
    for place in range(len(commuterEmploymentPlaces[0])):
        if commuterEmploymentPlaces[1][place]>0:
            workplace = commuterEmploymentPlaces[0][place]
            workforceForPlace = workforce[workerIterator:workerIterator+commuterEmploymentPlaces[1][place]]
            commuterEmployments.append([workplace,workforceForPlace])
            workerIterator = workerIterator+commuterEmploymentPlaces[1][place]

    #adding commuters IN to workforce
    #commuterHomePlaces [targetRegionList,targetRegionNumbers]
    for commuterHome in range(len(commuterHomePlaces[0])):
        if commuterHomePlaces[1][commuterHome] > 0:
            for i in range(commuterHomePlaces[1][commuterHome]):
                workforce.append(commuterHomePlaces[0][commuterHome]+str(i))
    
    #hack to shuffle commuters into rest of remaining workforce to avoid clustering commuters
    workforce = workforce[workerIterator:]
    random.shuffle(workforce)
    workerIterator = 0

    #assigning people as teachers to schools
    # primarySchools = [[] for x in range(len(schoolDistributions[0]))]
    # secondarySchools = [[] for x in range(len(schoolDistributions[1]))]
    # upperSecondarySchools = [[] for x in range(len(upperSecondarySchoolDistribution))]
    # schoolEmployees = [primarySchoolEmployees,secondarySchoolEmployees,upperSecondarySchoolEmployees]
    for school in primarySchools:
        for i in range(len(schoolEmployees[0])):
            school.append(workforce[workerIterator])
            workerIterator = workerIterator+1
    for school in secondarySchools:
        for i in range(len(schoolEmployees[1])):
            school.append(workforce[workerIterator])
            workerIterator = workerIterator+1
    for school in upperSecondarySchools:
        for i in range(len(schoolEmployees[2])):
            school.append(workforce[workerIterator])
            workerIterator = workerIterator+1

    #assigning people as teachers in kindergartens
    # approximately 5.5 employees per child based on 12562: Selected key figures kindergartens, by region, contents and year (M)
    for kindergarten in kindergartens:
        kindergartenWorkers = int(len(kindergarten)/5.5)
        for i in range(kindergartenWorkers):
            kindergarten.append(workforce[workerIterator])
            workerIterator = workerIterator+1

    #assigning people as nurses in nursing home
    # assuming a "bemanningsfaktor" of 0.75 based on anecdotal information
    for nursingHome in nursingHomes:
        for employee in range(int(len(nursingHome)*0.75)):
            nursingHome.append(workforce[workerIterator])
            workerIterator = workerIterator+1

    #assigning people to other in-municipality workplaces
    population = range(len(workplaceSizeDistribution[1]))
    weights = (workplaceSizeDistribution[1])
        # drawing random workplace size category according to distribution
        # assuming uniform distribution of workplace sizes within size categories!

    while 1:
        workplaceSizeCategory = random.choices(population, weights)
        workplaceSizeCategory = workplaceSizeCategory[0]
        workplaceSize = 0
        if workplaceSizeCategory == 0:
            workplaceSize = random.randint(1, 4)
        elif workplaceSizeCategory == 1:
            workplaceSize = random.randint(5, 9)
        elif workplaceSizeCategory == 2:
            workplaceSize = random.randint(10, 19)
        elif workplaceSizeCategory == 3:
            workplaceSize = random.randint(20, 49)
        elif workplaceSizeCategory == 4:
            workplaceSize = random.randint(50, 99)
        elif workplaceSizeCategory == 5:
            workplaceSize = random.randint(100, 249)
        elif workplaceSizeCategory == 6:
            #setting upper cap on workplace at 500, more or less at random
            workplaceSize = random.randint(250, 500)
        else:
            raise Exception("WorkplaceSizeCategory out of bounds!")
        workplace = []
        if workerIterator+workplaceSize>len(workforce):
            workplaceSize = len(workforce)-workerIterator
        for i in range(workplaceSize):
            workplace.append(workforce[workerIterator+i])
        workerIterator = workerIterator+workplaceSize
        workplaces.append(workplace)
        if workerIterator >= len(workforce)-1:
            break


    fileNumber = 1
    outputDirName = os.path.dirname(__file__)
    try:
        os.mkdir(outputDirName+"/output/")
    except:
        pass
    outputDirName = outputDirName+"/output/"+municipalityToGet+"/"
    try:
        os.mkdir(outputDirName)
    except:
        pass

    for i in range(99):
        try:
            with open(outputDirName+"idAndAge_"+municipalityToGet+"_"+str(fileNumber)+".txt") as f:
                test = f.readlines()
                fileNumber = fileNumber+1
        except IOError:
            break

    idAndAgeFileName = outputDirName+"idAndAge_"+municipalityToGet+"_"+str(fileNumber)+".txt"
    socialNetworkFileName = outputDirName+"socialNetwork_"+municipalityToGet+"_"+str(fileNumber)+".txt"

    # peopleAgeList - [[personID,age],...]
    outputFile = open(idAndAgeFileName, "w")
    for person in peopleAgeList:
        outputFile.write(str(person[0])+";"+str(person[1])+"\n")
    outputFile.close()

    outputFile = open(socialNetworkFileName, "w")
    
    # households - [[[personID,age],[personID,age],...],[[personID,age],[personID,age],...],...]
    for hh in households:
        if len(hh)>0:
            householdString = ""
            for person in hh:
                householdString = householdString+";"+str(person[0])
            outputFile.write("Household"+householdString+"\n")
        # else:
        #     print("Empty household")
    # primarySchools = [[personID,personID,...],[personID,personID,...]...]
    for school in primarySchools:
        if len(school)>0:
            outputFile.write("PrimarySchool;"+';'.join([str(person) for person in school])+"\n")
        # else:
        #     print("Empty primary school")
    # secondarySchools = [[personID,personID,...],[personID,personID,...]...]
    for school in secondarySchools:
        if len(school)>0:
            outputFile.write("SecondarySchool;"+';'.join([str(person) for person in school])+"\n")
        # else:
        #     print("Empty secondary school")
    # upperSecondarySchools = [[personID,personID,...],[personID,personID,...]...]
    for school in upperSecondarySchools:
        if len(school)>0:
            outputFile.write("UpperSecondarySchool;"+';'.join([str(person) for person in school])+"\n")
        # else:
        #     print("Empty upper secondary school")
    # workplaces - [[personID,...],[personID,...],...]
    for workplace in workplaces:
        if len(workplace)>0:
            outputFile.write("Workplace;"+';'.join([str(person) for person in workplace])+"\n")
        # else:
        #     print("Empty workplace")
    for commuterPlace in commuterEmployments:
        #[[place,[peopleIds]],[place,[peopleIds]],...]
        if len(commuterPlace)>0:
            outputFile.write("Commuters_"+commuterPlace[0]+";"+";".join([str(person) for person in commuterPlace[1]])+"\n")
        else:
            print("Empty workplace")
    # nursingHomes - [[personID,personID,...],[personID,personID,...]]
    for nursingHome in nursingHomes:
        if len(nursingHome)>0:
            outputFile.write("NursingHome;"+';'.join([str(person) for person in nursingHome])+"\n")
        # else:
        #     print("Empty nursing home")
    # kindergartens - [[personID,personID,...],[personID,personID,...]]
    for kindergarten in kindergartens:
        if len(kindergarten)>0:
            outputFile.write("Kindergarten;"+';'.join([str(person) for person in kindergarten])+"\n")
        # else:
        #     print("Empty kindergarten")
    outputFile.close()
    print("Network for "+municipalityToGet+" generated")
    print("Put "+str(len(peopleAgeList))+" people in "+str(len(households))+" households, "+str(len(kindergartens))+" kindergartens, "+str(len(primarySchools))+" primary schools, "+str(len(secondarySchools))+" lower secondary schools, "+str(len(upperSecondarySchools))+" upper secondary schools, "+str(len(workplaces))+" workplaces, and "+str(len(nursingHomes))+" nursing homes.")
    print("")



    ###########################
    generatedAgeDistribution = [0 for x in range(106)]
    for i in range(len(peopleAgeList)):
        try:
            generatedAgeDistribution[peopleAgeList[i][1]] = generatedAgeDistribution[peopleAgeList[i][1]]+1
        except:
            print("EXCEPTION")
            print(peopleAgeList[i][1])

    outputFile = open("ageDistCheck"+municipalityToGet+".csv", "w")
    outputFile.write("RealAges,GeneratedAges\n")
    for i in range(106):
        outputFile.write(str(ageDistribution[i])+","+str(generatedAgeDistribution[i])+"\n")
    outputFile.close()
    ###########################

    #save in file: cliqueType;id1;id2;...
    #e.g.:
    # Household 1 2 3 4 5 6
    # Household 7 8
    # Work 1 7 11
    # Work 2, 10, 14, 15
    # School 3, 13, 19, 24

    #separate file: id;age
    #e.g.:
    # 0;14
    # 1;32
    # 2;21

    #TODO:
    #   Restructure the ways schools are made so that age groupings match empirical data more closely
    #   Find and implement better data for employment rates for age groups etc.
    #   Add workers in schools, kindergartens, nursing homes, hospitals
    #   Integrate householdSizeDistribution
    #   Add hospitals
    #   School data missing for some municipalities due to outdated municipality names
    #       - Kommune (Legacy): https://data-nxr-fellestjeneste.udir.no/swagger/ui/index
    #   More data on kindergartens
    #       - https://data-nbr.udir.no/swagger/ui/index
    #   Add sanity checks (demographic distribution vs original data, etc)
    #   Find and implement better data for compositions of couples, families, sibling flocks etc.
    #   Find better school data? (replace 4.5 hack) https://www.udir.no/tall-og-forskning/statistikk/statistikk-videregaende-skole/elevtall-i-videregaende-skole/elevtall-fylker-og-skoler/

# generateSocialNetworkForRegion("Moss")
# generateSocialNetworkForRegion("Holmestrand")
# generateSocialNetworkForRegion("Sandefjord")
# generateSocialNetworkForRegion("Elverum")
# generateSocialNetworkForRegion("Rendalen")
# generateSocialNetworkForRegion("Rakkestad")
# generateSocialNetworkForRegion("Lørenskog")
# generateSocialNetworkForRegion("Molde")
# generateSocialNetworkForRegion("Halden")
# generateSocialNetworkForRegion("Oslo")

# osloStart = time.time()
# for i in range(3):
#     generateSocialNetworkForRegion("Oslo")
# osloEnd = time.time()

# trondheimStart = time.time()
# for i in range(3):
#     generateSocialNetworkForRegion("Trondheim")
# trondheimEnd = time.time()

# osloTime = osloEnd - osloStart
# print(osloTime)
# osloMinutes = str(math.floor(osloTime/60))
# osloSeconds = str(int(osloTime%60))
# print("Time elapsed, Oslo: "+osloMinutes+" minutes and "+osloSeconds+" seconds")

# trondheimTime = trondheimEnd - trondheimStart
# print(trondheimTime)
# trondheimMinutes = str(math.floor(trondheimTime/60))
# trondheimSeconds = str(int(trondheimTime%60))
# print("Time elapsed, Trondheim: "+trondheimMinutes+" minutes and "+trondheimSeconds+" seconds")

# generateSocialNetworkForRegion("Bergen")
# generateSocialNetworkForRegion("Stavanger")
# generateSocialNetworkForRegion("Tromsø")
# generateSocialNetworkForRegion("Trøgstad")