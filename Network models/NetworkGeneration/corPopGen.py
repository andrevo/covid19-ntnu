# -*- coding: utf-8 -*-

import pandas as pd
import random
import warnings
import copy
import math
import os
import time
import cProfile, pstats
from io import StringIO


# # # # #
# # # # # Functions to get the different distributions from the csv files generated by croPopDat.py
# # # # #

def getAgeDistribution(queryMunicipality,dataDirName):
    #07459: Population, by sex and one-year age groups (M) 1986 - 2020
    #This function uses the above dataset from SSB found in dataDirName to return
    # "ageDistribution", the number of people at any gives age across
    # ages 0 to 105 for the given queryMunicipality as a python list
    pop_age_region_dataFrame = pd.read_csv(dataDirName+"pop_age_region.csv")
    pop_age_region_dataFrame["region"] = pop_age_region_dataFrame["region"].str.lower()
    osloAges = pop_age_region_dataFrame[pop_age_region_dataFrame['region'].str.contains(queryMunicipality.lower())]
    # osloAges = pop_age_region_dataFrame.loc[pop_age_region_dataFrame['region'] == queryMunicipality.lower()+" (-2019)"]
    ageDistribution = []
    for i in range(106):
        queryAge = str(i)+" years"
        if i==1:
            queryAge = "1 year"
        ageVals = osloAges.loc[osloAges['age'] == queryAge]
        ageDistribution.append(sum(ageVals['value']))
    print("Generated age distribution with "+str(sum(ageDistribution))+" people")
    return ageDistribution

def getHouseholdSizeDistribution(queryMunicipality,dataDirName):
    #06079: Private households and persons in private households, by size of household (per cent) (M) (UD) 2005 - 2019
    #This function uses the above dataset from SSB to return
    # "householdSizeDistribution", which is the distribution of household sizes in terms of the
    # proportion of households that contain 1, 2, 3, 4 and 5+ people in them as a python list
    household_sizes_dataFrame = pd.read_csv(dataDirName+"household_sizes.csv")
    household_sizes_dataFrame["region"] = household_sizes_dataFrame["region"].str.lower()
    regionHouseholds = household_sizes_dataFrame[household_sizes_dataFrame['region'].str.contains(queryMunicipality.lower())]
    regionHouseholds = regionHouseholds.loc[regionHouseholds['contents'] == 'Persons in private households']
    regionHouseholds['value'].tolist()
    householdSizeDistribution = regionHouseholds['value'].tolist()
    return householdSizeDistribution

def getHouseHoldTypeDistribution(queryMunicipality,dataDirName):
    #06070: Privathusholdninger, etter husholdningstype (K) (B) 2005 - 2019
    #This function uses the above dataset from SSB to return
    #  "householdData", which is the type of household (as given in "householdTypes")
    # and the number of households of the respective types for the given municipality
    # as two lists in a nested python list ("[householdTypes,householdNumbers]")
    household_type_dataFrame = pd.read_csv(dataDirName+"household_type.csv")
    household_type_dataFrame["region"] = household_type_dataFrame["region"].str.lower()
    regionHouseholds = household_type_dataFrame[household_type_dataFrame['region'].str.contains(queryMunicipality.lower())]
    # print(regionHouseholds)
    householdTypes = ["Living alone","Couple without resident children","Couple with small children (youngest child 0-5 years)","Couple with older children (youngest child 6-17 years)","Lone parent with small children (youngest child 0-5 years)","Lone parent with older children (youngest child 6-17 years)","One family households with adult children (youngest child 18 years and over","Two or more-family households without resident children 0-17 years","Two or more-family households with small children (youngest child 0-5 years)","Two or more-family households with older children (youngest child 6-17 years)"]
    householdNumbers = []
    for i in householdTypes:
        householdNumbers.append(sum(regionHouseholds.loc[regionHouseholds['type of household'] == i]['value']))
    assert len(householdTypes)==len(householdNumbers)
    householdData = [householdTypes,householdNumbers]
    # 0 "Living alone"
    # 1 "Couple without resident children"
    # 2 "Couple with small children (youngest child 0-5 years)"
    # 3 "Couple with older children (youngest child 6-17 years)"
    # 4 "Lone parent with small children (youngest child 0-5 years)"
    # 5 "Lone parent with older children (youngest child 6-17 years)"
    # 6 "One family households with adult children (youngest child 18 years and over"
    # 7 "Two or more-family households without resident children 0-17 years"
    # 8 "Two or more-family households with small children (youngest child 0-5 years)"
    # 9 "Two or more-family households with older children (youngest child 6-17 years)"
    ##SINGLE PARENT OR NOT IS IMPORTANT! 
    ## Living with both parents, total	
    #Children with no siblings	127 194
    #Children with siblings, total	709 612 
    #TOT = 836,806
    ## Living with one of the parents, total	
    #Children with no siblings	99 231
    #Children with siblings, total	175 450
    #TOT = 274,681â€¬
    ## Fractions with both/single parents
    #No siblings 0.56/0.44
    #Siblings 0.80/0.20
    #TOT 0.75/0.25
    print("Generated household type distribution with "+str(sum(householdNumbers))+" households")
    return householdData

def getSiblingFlockSizeDistribution(dataDirName):
    #06206: Children 0-17 years, by number of siblings and the child's age 2001 - 2019
    #This function uses data from the above given dataset from SSB to calculate the proportion
    # of sibling flocks that fall in the different size categories (1, 2, 3, 4, 5, 6+).
    # Importantly, it derives this statistic, which speaks of sibling flock sizes, from data
    # on how many siblings children tend to have, and how many children tend to have siblings.
    # These proportions, as decimal fractions, are returned as 
    # "siblingFlockSizeDistribution", a python list
    siblingFlockSizeDistribution = [0.197,0.584*0.803,0.311*0.803,0.073*0.803,0.019*0.803,0.012*0.803]
    for i in range(len(siblingFlockSizeDistribution)):
        siblingFlockSizeDistribution[i] = siblingFlockSizeDistribution[i]/(1+i)
    siblingFlockSum = sum(siblingFlockSizeDistribution[1:])
    for i in range(len(siblingFlockSizeDistribution)-1):
        siblingFlockSizeDistribution[i+1] = 0.803*siblingFlockSizeDistribution[i+1]/siblingFlockSum
    assert sum(siblingFlockSizeDistribution)>0.99 and sum(siblingFlockSizeDistribution)<1.01
    print("Generated sibling flock size distribution")
    return siblingFlockSizeDistribution
    
def getSecondaryEducationProportion(dataDirName):
    #08947: Pupils, apprentices, students and participants in upper secondary education, by sex, age and type of school/institution 2006 - 2019
    #This function uses data from the above SSB dataset to approximate the proportion of secondary school attendance for children and young
    # adults aged 16 to 20, which is returned as a float

    #upper_secondary_schoolers_dataFrame = pd.read_csv(dataDirName+"upper_secondary_schoolers.csv")
    #2,"Public maintained schools, total",Both sexes,16-18 years,"Pupils, apprentices, students and participants",2019,176923
    #3,"Public maintained schools, total",Both sexes,19-24 years,"Pupils, apprentices, students and participants",2019,58448
    #total number of people 16-24 in upper secondary school: 176923+58448=235371
    #total proportion of people 16-24 in upper secondary school: 235371/(32300+31684+32696+34517+34794+34159+35129+36127+36264+30722+30367+30861+32067+32019+32005+32688+33822+33822)=0.394
    #people 16-20 divided by people 16-24 in upper secondary school: 235371/(32300+31684+32696+34517+34794+30722+30367+30861+32067+32019)=0.731
    # 16,The whole country,Males,16 years,Persons,2020,32300
    # 17,The whole country,Males,17 years,Persons,2020,31684
    # 18,The whole country,Males,18 years,Persons,2020,32696
    # 19,The whole country,Males,19 years,Persons,2020,34517
    # 20,The whole country,Males,20 years,Persons,2020,34794
    # 21,The whole country,Males,21 years,Persons,2020,34159
    # 22,The whole country,Males,22 years,Persons,2020,35129
    # 23,The whole country,Males,23 years,Persons,2020,36127
    # 24,The whole country,Males,24 years,Persons,2020,36264
    # 122,The whole country,Females,16 years,Persons,2020,30722
    # 123,The whole country,Females,17 years,Persons,2020,30367
    # 124,The whole country,Females,18 years,Persons,2020,30861
    # 125,The whole country,Females,19 years,Persons,2020,32067
    # 126,The whole country,Females,20 years,Persons,2020,32019
    # 127,The whole country,Females,21 years,Persons,2020,32005
    # 128,The whole country,Females,22 years,Persons,2020,32688
    # 129,The whole country,Females,23 years,Persons,2020,33822
    # 130,The whole country,Females,24 years,Persons,2020,33822
    warnings.warn("WARNING! SECONDARY EDUCATION PROPORTION DATA IS GUESSTIMATE")
    return 0.6

def getWorkplaceSizeDistribution(queryMunicipality,dataDirName):
    #10308: Establishments, by the enterprises sector and number of employees (M) 2012 - 2020
    #This function uses the above dataset from SSB to return two python lists in a nested list: 
    # 1) the different establishment sizes from the dataset
    # 2) the number of total employees in each category of establishment in the given municipality (kommune)
    establishments_dataFrame = pd.read_csv(dataDirName+"establishments.csv")
    establishments_dataFrame["region"] = establishments_dataFrame["region"].str.lower()
    regionEstablishments = establishments_dataFrame[establishments_dataFrame['region'].str.contains(queryMunicipality.lower())]
    employeeBins = ["1-4 employees","5-9 employees","10-19 employees","20-49 employees","50-99 employees","100 - 249 employees","250 employees and more"]
    employeeNumbers = []
    for i in employeeBins:
        employeeNumbers.append(sum(regionEstablishments.loc[regionEstablishments['number of employees'] == i]['value']))
    assert len(employeeBins) == len(employeeNumbers)
    print("Generated workplace size distribution with "+str(len(employeeNumbers))+" workplaces and "+str(sum(employeeNumbers))+" employees")
    return [employeeBins,employeeNumbers]

def getSchoolSizeDistribution(queryMunicipality,dataDirName):

    #This function uses data from the NSR (Norsk skoleregister) API and returns 
    # "[primarySchoolSizes,secondarySchoolSizes,schoolAssociations],upperSecondarySchoolDistribution"
    # where "primarySchoolSizes" and "secondarySchoolSizes" are lists of the sizes of all school groups
    # with primary and secondary school age children given as number of pupils,
    # "schoolAssociations" is a list that links any given secondary school to a set of primary schools, and
    # "upperSecondarySchoolDistribution" is a list with all the sizes of all school groups with upper secondary school age children

    #loading data
    allSchools_dataFrame = pd.read_csv(dataDirName+"allSchools.csv")
    allSchools_dataFrame["KommuneNavn"] = allSchools_dataFrame["KommuneNavn"].str.lower()
    regionSchools = allSchools_dataFrame[allSchools_dataFrame['KommuneNavn'].str.contains(queryMunicipality.lower())]
    # print("len(regionSchools['KommuneNavn'])")
    if len(regionSchools['KommuneNavn']) == 0:
        print("Data for schools in "+queryMunicipality+" is missing.")
        
    lowerSchools = regionSchools.loc[regionSchools['ErGrunnSkole'] == True]
    upperSchools = regionSchools.loc[regionSchools['ErVideregaaendeSkole'] == True]
    # upperSchools.to_csv(dataDirName+'upperSchools_'+queryMunicipality+'.csv')
    # print(upperSchools)

    #converting number of pupils, school steps and employees to lists
    lowerSchoolPupilNumber = lowerSchools['Elevtall'].tolist()
    lowerSchoolStepFrom = lowerSchools['SkoleTrinnFra'].tolist()
    lowerSchoolStepTo = lowerSchools['SkoleTrinnTil'].tolist()
    lowerSchoolEmployeesFrom = lowerSchools['AnsatteFra'].tolist()
    lowerSchoolEmployeesTo = lowerSchools['AnsatteTil'].tolist()


    #converting number of pupils, school steps and employees to lists
    upperSchoolPupilNumber = upperSchools['Elevtall'].tolist()
    upperSchoolStepFrom = upperSchools['SkoleTrinnFra'].tolist()
    upperSchoolStepTo = upperSchools['SkoleTrinnTil'].tolist()
    upperSchoolEmployeesFrom = upperSchools['AnsatteFra'].tolist()
    upperSchoolEmployeesTo = upperSchools['AnsatteTil'].tolist()


    #generating lower school sizes and employee numbers

    primarySchoolSizes = []
    primarySchoolEmployees = []
    secondarySchoolSizes = []
    secondarySchoolEmployees = []

    for school in range(len(lowerSchoolPupilNumber)):
        try:
            schoolEmployees = int((lowerSchoolEmployeesFrom[school]+lowerSchoolEmployeesTo[school])/2)
            schoolPupils = int(lowerSchoolPupilNumber[school])
            if lowerSchoolStepFrom[school]==1 and lowerSchoolStepTo[school]==7:
                primarySchoolSizes.append(schoolPupils)
                primarySchoolEmployees.append(schoolEmployees)
            elif lowerSchoolStepFrom[school] == 8 and lowerSchoolStepTo[school] == 10:
                secondarySchoolSizes.append(schoolPupils)
                secondarySchoolEmployees.append(schoolEmployees)
            elif lowerSchoolStepFrom[school]==1 and lowerSchoolStepTo[school]==10:
                primarySchoolSizes.append(int(0.7*schoolPupils))
                primarySchoolEmployees.append(schoolEmployees*0.7)
                secondarySchoolSizes.append(int(0.3*schoolPupils))
                secondarySchoolEmployees.append(int(schoolEmployees*0.3))
            elif lowerSchoolStepFrom[school]==1 and lowerSchoolStepTo[school]==13:
                primarySchoolSizes.append(int(7/13*schoolPupils))
                primarySchoolEmployees.append(int(schoolEmployees*7/13))
                secondarySchoolSizes.append(int(3/13*schoolPupils))
                secondarySchoolEmployees.append(int(schoolEmployees*3/13))
            elif lowerSchoolStepFrom[school]==1 and lowerSchoolStepTo[school]==12:
                primarySchoolSizes.append(int(7/12*schoolPupils))
                primarySchoolEmployees.append(int(schoolEmployees*7/12))
                secondarySchoolSizes.append(int(3/12*schoolPupils))
                secondarySchoolEmployees.append(int(schoolEmployees*3/12))
            elif lowerSchoolStepFrom[school]==8 and lowerSchoolStepTo[school]==13:
                secondarySchoolSizes.append(int(0.5*schoolPupils))
                secondarySchoolEmployees.append(int(schoolEmployees*0.5))
            elif lowerSchoolStepFrom[school]==1 and lowerSchoolStepTo[school]==6:
                primarySchoolSizes.append(schoolPupils)
                primarySchoolEmployees.append(schoolEmployees)
        # else:
            # print("lowerSchoolStepFrom[school]: "+str(lowerSchoolStepFrom[school])+", lowerSchoolStepTo[school]: "+str(lowerSchoolStepTo[school])+", lowerSchoolPupilNumber[school]: "+str(lowerSchoolPupilNumber[school]))
        except:
            print("Couldn't generate school data for lower school #"+str(school)+" in "+queryMunicipality+" due to nan values")

    #generating upper school sizes and employee numbers
    
    upperSecondarySchoolDistribution = []
    upperSecondarySchoolEmployees = []
    
    for school in range(len(upperSchoolPupilNumber)):
        try:
            schoolEmployees = int((upperSchoolEmployeesFrom[school]+upperSchoolEmployeesTo[school])/2)
            #numbers are missing for many upper secondary schools
            if math.isnan(upperSchoolPupilNumber[school]):
                #there appears to be numbers for employees for a lot more, and there appears to be roughly (read: sketchy approximation) 4.5 students per employee
                sketchyApproximation = upperSchoolEmployeesTo[school]*4.5
                if math.isnan(sketchyApproximation):
                    sketchyApproximation = 0
                upperSchoolPupilNumber[school] = int(sketchyApproximation)
            if upperSchoolStepFrom[school] == 11 and upperSchoolStepTo[school] == 13:
                upperSecondarySchoolDistribution.append(upperSchoolPupilNumber[school])
                upperSecondarySchoolEmployees.append(schoolEmployees)
            elif upperSchoolStepFrom[school] == 8 and upperSchoolStepTo[school] == 13:
                upperSecondarySchoolDistribution.append(int(0.5*upperSchoolPupilNumber[school]))
                upperSecondarySchoolEmployees.append(int(schoolEmployees*0.5))
            elif upperSchoolStepFrom[school] == 1 and upperSchoolStepTo[school] == 13:
                upperSecondarySchoolDistribution.append(int(3/13*upperSchoolPupilNumber[school]))
                upperSecondarySchoolEmployees.append(int(schoolEmployees*3/13))
            elif upperSchoolStepFrom[school] == 1 and upperSchoolStepTo[school] == 12:
                upperSecondarySchoolDistribution.append(int(2/12*upperSchoolPupilNumber[school]))
                upperSecondarySchoolEmployees.append(int(schoolEmployees*2/12))
        except:
            print("Couldn't generate school data for upper school #"+str(school)+" in "+queryMunicipality+" due to nan values")
        # else:
        #     print("upperSchoolStepFrom[school]: "+str(upperSchoolStepFrom[school])+", upperSchoolStepTo[school]: "+str(upperSchoolStepTo[school])+", upperSchoolPupilNumber[school]: "+str(upperSchoolPupilNumber[school]))

    #associating primary schools with lower secondary schools, generating implicit geographical linkage
    if not len(primarySchoolSizes)>len(secondarySchoolSizes):
        print("primarySchoolSizes:")
        print(primarySchoolSizes)
        print("secondarySchoolSizes:")
        print(secondarySchoolSizes)
    if len(primarySchoolSizes) == 0:
        print("No primary schools found. Generating one.")
        primarySchoolSizes = [10]
    if len(secondarySchoolSizes) == 0:
        print("No secondary schools found. Generating one.")
        secondarySchoolSizes = [10]
    assert(len(primarySchoolSizes)>=len(secondarySchoolSizes))
    primarySchoolSizes.sort(reverse = True)
    secondarySchoolSizes.sort(reverse = True)
    
    schoolAssociations = [[] for x in range(len(secondarySchoolSizes))] #linking each secondary schools to set of primary schools. index is secondary school, values are lists of primary schools

    #iteratively assigning the biggest primary school to the secondary school with the largest proportional amount of spaces left
    secondarySchoolSlotsVacant = copy.deepcopy(secondarySchoolSizes)
    for school in range(len(primarySchoolSizes)):
        schoolIndex = secondarySchoolSlotsVacant.index(max(secondarySchoolSlotsVacant))
        schoolAssociations[schoolIndex].append(school)
        secondarySchoolSlotsVacant[schoolIndex] = secondarySchoolSlotsVacant[schoolIndex]-int(3*primarySchoolSizes[school])

    schoolEmployees = [primarySchoolEmployees,secondarySchoolEmployees,upperSecondarySchoolEmployees]

    print("Generated school size distribution, with "+str(len(primarySchoolSizes))+" primary schools, "+str(len(secondarySchoolSizes))+" secondary schools, and "+str(len(upperSecondarySchoolDistribution))+" high schools")
    
    return [primarySchoolSizes,secondarySchoolSizes,schoolAssociations],upperSecondarySchoolDistribution,schoolEmployees #schoolAssocations has secondary school ID as index and primary school IDs as value

def getElderlyHomeDistribution(queryMunicipality,queryCounty,dataDirName):
    #This function uses the data set #11933: Care institutions - rooms, by region, contents and year (M)
    # from SSB and returns "nursingHomeSizes,[ageBins,ageNumbers]", where "nursingHomeSizes" is 
    # a list of the size of all nursing rooms in the municipality, "ageBins"
    # is a list of strings describing the age groups in nursing homes, and "ageNumbers" is a list of
    # all the patients in the corresponding ageBin in nursing homes in the given municipality
    
    #09929: Nursing and care institutions and beds, by ownership (C) 2009 - 2018

    # nursing_spots_dataFrame = pd.read_csv(dataDirName+"nursing_spots.csv")

    #11933: Care institutions - rooms, by region, contents and year (M)
    nursingHomeRooms_dataFrame = pd.read_csv(dataDirName+"nursingHomeRooms.csv")

    #generating nursing home size distribution by dividing the number of beds by the number of institutions and assuming some kind of middle-heavy distribution
    #generating nursing homes number by dividing number of patients by average nursing home size
    #distribution below is "weighting for each bin of 10"
    nursingHomeRooms_dataFrame["region"] = nursingHomeRooms_dataFrame["region"].str.lower()
    regionNursingHomeRooms = nursingHomeRooms_dataFrame[nursingHomeRooms_dataFrame['region'].str.contains(queryMunicipality.lower())]
    numberOfRooms = sum(pd.to_numeric(regionNursingHomeRooms.loc[regionNursingHomeRooms['contents'] == "Rooms, total (number)"]['value']))

    # regionNursingSpots = nursing_spots_dataFrame[nursing_spots_dataFrame['region'].str.contains(queryCounty)]
    # regionNursingSpots = regionNursingSpots[regionNursingSpots['ownership'].str.contains("total")]
    # numberOfBeds = sum(regionNursingSpots.loc[regionNursingSpots['contents'] == "Beds"]['value'])
    # numberOfInstitutions = sum(regionNursingSpots.loc[regionNursingSpots['contents'] == "Institutions"]['value'])
    
    # meanNursingHomeSize = numberOfBeds/numberOfInstitutions

    #setting mean nursing home size to 40; it's 50 for Oslo, assuming smaller average
    meanNursingHomeSize = 40
    if math.isnan(numberOfRooms):
        numberOfRooms = 0
    numberOfInstitutions = int(numberOfRooms/meanNursingHomeSize)
    nursingHomeSizes = [meanNursingHomeSize for x in range(numberOfInstitutions)]
   
    #04469: Bebuarar i bustader kommunen disponerer til pleie- og omsorgsformÃ¥l, etter alder (K) 2002 - 2018
    nursing_patients_dataFrame = pd.read_csv(dataDirName+"nursing_patients.csv")
    nursing_patients_dataFrame["region"] = nursing_patients_dataFrame["region"].str.lower()
    regionNursingHomes = nursing_patients_dataFrame[nursing_patients_dataFrame['region'].str.contains(queryMunicipality.lower())]
    regionNursingHomes = regionNursingHomes.loc[nursing_patients_dataFrame['contents'] == 'Residents in dwellings']
    ageBins = ["Under 67 years","67-74 years","75-79 years","80-84 years","85-89 years","90 years or older"]
    ageNumbers = []
    for i in ageBins:
        numberAtAge = sum(regionNursingHomes.loc[regionNursingHomes['age'].isin([i])]['value'])
        if math.isnan(numberAtAge):
            print("Nursing home resident information unavailable! Default distribution assumed")
            meanAgeGroupSize = int(numberOfRooms/len(ageBins))
            ageGroupWeights = [0.5,0.5,0.8,1.2,1.5,1.5]
            assert sum(ageGroupWeights)/len(ageGroupWeights) == 1
            ageNumbers = [int(meanAgeGroupSize*ageGroupWeights[x]) for x in range(len(ageBins))]
            break
        else:
            ageNumbers.append(int(numberAtAge))
    assert len(ageBins) == len(ageNumbers)

    # print("numberOfRooms: "+str(numberOfRooms)+", total patients: "+str(sum(ageNumbers)))
    # print("Age distribution: u67: "+str(ageNumbers[0])+", 67-74: "+str(ageNumbers[1])+", 75-79: "+str(ageNumbers[2])+", 80-84: "+str(ageNumbers[3])+", 85-89: "+str(ageNumbers[4])+", 90+: "+str(ageNumbers[5]))

    # #determining number of nursing homes
    # numberOfNursingHomes = int(sum(ageNumbers)/meanNursingHomeSize)
    # #generating nursing homes
    # population = range(len(nursingHomeSizeDistribution))
    # weights = copy.deepcopy(nursingHomeSizeDistribution)
    # nursingHomeSizes = []
    # for i in range(numberOfNursingHomes):
    #     nursingHomeSize = random.choices(population, weights)
    #     nursingHomeSize = nursingHomeSize[0]
    #     nursingHomeSizes.append(nursingHomeSize)
    if not nursingHomeSizes and sum(ageNumbers)>0:
        print("No information on nursing home sizes available, assuming mean of 40 patients per nursing home.")
        for x in range(math.ceil(sum(ageNumbers[1:])/40)):
            nursingHomeSizes.append(40)
    
    print("Generated "+str(len(nursingHomeSizes))+" nursing homes")

    return nursingHomeSizes,[ageBins,ageNumbers]

def getKindergartenDistribution(queryMunicipality,dataDirName):

    #This function integrates the 3 datasets from SSB given below to return
    # "kindergartenSizes,kindergartenProportions", where "kindergartenSizes"
    # is a list of all the kinder gartens' sizes in the given municipality,
    # while "kindergartenProportions" is the proportion of children at a given
    # age that attend kindergarten
    
    #   loading relevant data

    #09220: Kindergartens, by ownership (M) 1987 - 2019
    kids_in_kindergartens_dataFrame = pd.read_csv(dataDirName+'kindergartenNumbers.csv')
    kids_in_kindergartens_dataFrame["region"] = kids_in_kindergartens_dataFrame["region"].str.lower()
    kindergartensRegion = kids_in_kindergartens_dataFrame[kids_in_kindergartens_dataFrame['region'].str.contains(queryMunicipality.lower())]
    
    #09169: Barn i barnehager, etter region, barnehagetype, statistikkvariabel og Ã¥r
    kindergartens_in_places = pd.read_csv(dataDirName+'kidsInKindergartens.csv')
    kindergartens_in_places["region"] = kindergartens_in_places["region"].str.lower()
    kindergartenKidsRegion = kindergartens_in_places[kindergartens_in_places['region'].str.contains(queryMunicipality.lower())]

    #12562: Selected key figures kindergartens, by region, contents and year (M)
    kinderGartenAttendanceAndPersonnel = pd.read_csv(dataDirName+'kinderGartenAttendanceAndPersonnel.csv')
    kinderGartenAttendanceAndPersonnel["region"] = kinderGartenAttendanceAndPersonnel["region"].str.lower()
    kinderGartenAttendanceAndPersonnelRegion = kinderGartenAttendanceAndPersonnel[kinderGartenAttendanceAndPersonnel['region'].str.contains(queryMunicipality.lower())]
    #"Percentage of 1-2 year-olds in kindergarten (per cent)", "Percentage of 3-5 year-olds in kindergarten (per cent)"
    smallKidsRates = sum(kinderGartenAttendanceAndPersonnelRegion.loc[kinderGartenAttendanceAndPersonnelRegion['contents'] == "Percentage of 1-2 year-olds in kindergarten (per cent)"]['value'])
    bigKidsRates = sum(kinderGartenAttendanceAndPersonnelRegion.loc[kinderGartenAttendanceAndPersonnelRegion['contents'] == "Percentage of 3-5 year-olds in kindergarten (per cent)"]['value'])


    ageGroups = ["0 years","1 year","2 years","3 years","4 years","5 years","6 years"]
    numberOfKidsPerYear = [sum(kindergartenKidsRegion.loc[kindergartenKidsRegion['age'] == ageGroups[i]]['value']) for i in range(7)]
    numberOfKids = sum(numberOfKidsPerYear)

    numberOfKindergartens = sum(kindergartensRegion['value'])

    #assuming (somewhat naively) homogeneous size of kindergartens in lieu of better data
    if numberOfKindergartens<=0:
        print("numberOfKindergartens: "+str(numberOfKindergartens)+", numberOfKids: "+str(numberOfKids))
        numberOfKindergartens = 1
    meanKindergartenSize = int(numberOfKids/numberOfKindergartens)
    
    kindergartenSizes = [meanKindergartenSize for x in range(numberOfKindergartens)]
    kindergartenProportions = [0]+[smallKidsRates/100 for x in range(2)]+[bigKidsRates/100 for x in range(3)]

    print("Generated "+str(len(kindergartenSizes))+" kindergartens")

    return kindergartenSizes,kindergartenProportions

def getCommuteData(queryMunicipality,dataDirName):

    #This function...
    
    #   loading relevant data

    #03321: Employed persons (aged 15-74) per 4th quarter, by municipality of work, municipality of residence, contents and year
    commuting_dataFrame = pd.read_csv(dataDirName+'municipalityResidenceEmployment.csv')
    if queryMunicipality == "Oslo":
        queryMunicipality = "Oslo municipality"

    commuting_dataFrame["municipality of residence"] = commuting_dataFrame["municipality of residence"].str.lower()
    commuting_dataFrame["municipality of work"] = commuting_dataFrame["municipality of work"].str.lower()

    commutersFromRegion = commuting_dataFrame[commuting_dataFrame['municipality of residence'].str.contains(queryMunicipality.lower())]
    commutersFromRegion = commutersFromRegion[~commutersFromRegion['municipality of work'].str.contains(queryMunicipality.lower())]
    originRegionList = commutersFromRegion['municipality of work'].tolist()
    originRegionNumbers = commutersFromRegion['value'].tolist()
    for i in range(len(originRegionList)):
        originRegion = originRegionList[i].split(" ")
        if len(originRegion)>1:
            originRegion = originRegion[0]
            originRegionList[i] = originRegion
    commuterEmploymentPlaces = [originRegionList,originRegionNumbers]

    commutersToRegion = commuting_dataFrame[commuting_dataFrame['municipality of work'].str.contains(queryMunicipality.lower())]
    commutersToRegion = commutersToRegion[~commutersToRegion['municipality of residence'].str.contains(queryMunicipality.lower())]
    targetRegionList = commutersToRegion['municipality of residence'].tolist()
    targetRegionNumbers = commutersToRegion['value'].tolist()
    for i in range(len(targetRegionList)):
        targetRegion = targetRegionList[i].split(" ")
        if len(targetRegion)>1:
            targetRegion = targetRegion[0]
            targetRegionList[i] = targetRegion
    commuterHomePlaces = [targetRegionList,targetRegionNumbers]

    print("Generated commuters, with "+str(sum(targetRegionNumbers))+" commuters going out, and "+str(sum(originRegionNumbers))+" commuters coming in")

    return commuterEmploymentPlaces,commuterHomePlaces

def getWorkAgeProbability(queryMunicipality,dataDirName):

    #This function...
    
    #   loading relevant data

    #06445: Employed persons, by place of residence, sex and age (per cent). 4th quarter (M) 2005 - 2019
    employmentRate_dataFrame = pd.read_csv(dataDirName+'employementRate.csv')
    # if queryMunicipality is "Oslo":
    #     queryMunicipality = "Oslo municipality"
    # else:
    #     queryMunicipality = queryMunicipality+" (-2019)"
    employmentRate_dataFrame["region"] = employmentRate_dataFrame["region"].str.lower()
    employmentRateForRegion = employmentRate_dataFrame[employmentRate_dataFrame['region'].str.contains(queryMunicipality.lower())]
    if employmentRateForRegion.empty:
        employmentRateForRegion = employmentRate_dataFrame.loc[employmentRate_dataFrame['region'] == queryMunicipality.lower()+" (-2019)"]
    employmentRateForRegion = employmentRateForRegion.loc[employmentRateForRegion['sex'] == "Both sexes"]
    ageGroups = employmentRateForRegion['age'].tolist()
    ageNumbers = employmentRateForRegion['value'].tolist()

    assert(ageGroups[0] == "15-74 years")
    assert(ageGroups[1] == "15-19 years")
    assert(ageGroups[-1] == "67-74 years")

    if sum(ageNumbers) == 0:
        # setting to national average as default if no data is available: 67.1,35.6,64,80,82.4,67.4,18.8
        print("No employment rate by age available for "+queryMunicipality+", assuming national average")
        ageNumbers = [67.1,35.6,64,80,82.4,67.4,18.8]
    
    workAgeProbability = [[0,14,0],[15,19,ageNumbers[1]],[20,24,ageNumbers[2]],[25,39,ageNumbers[3]],[40,54,ageNumbers[4]],[55,66,ageNumbers[5]],[67,74,ageNumbers[6]],[74,110,0]]

    print("Generated probabilities of people working at given ages")

    return workAgeProbability


# Function for building social network
def generateSocialNetworkForRegion(municipalityToGet,nNetworks):


    #This function integrates the data from all the other functions
    # to generate the actual social network linking people into
    # cliques, such as households, workplaces, schools, etc.

    #checking if correct number of files is already generated
    try:
        outputDirName = os.path.dirname(__file__)+"/output/"+municipalityToGet.replace(" ","_")+"/"
        with open(outputDirName+"idAndAge_"+municipalityToGet.replace(" ","_")+"_"+str(nNetworks)+".txt") as f:
            test = f.readlines()
            print(str(nNetworks)+" already generated for "+municipalityToGet+"\n")
            return 0
    except:
        pass
            
    print("Generating cliques and social network for "+municipalityToGet)

    dataDirName = os.path.dirname(__file__)
    dataDirName = dataDirName+"/populationData/"
    
    #since some data only exists with county (fylke) resolution, and not municipality (kommune) resolution,
    # a conversion is required:
    countyToGet = "Oslo"
    if municipalityToGet.lower() != "oslo":
        countyAndMunicipalityFile = open(dataDirName+"fylker-kommuner-2019-2020-alle.csv", encoding = "utf-8")
        fylkesNr2019 = []
        fylkesNavn2019 = []
        kommuneNr2019 = []
        kommuneNavn2019 = []
        fylkesNr2020 = []
        fylkesNavn2020 = []
        kommuneNr2020 = []
        kommuneNavn2020 = []
        for line in countyAndMunicipalityFile.readlines():
            splitLine = line.split(",")
            fylkesNr2019.append(splitLine[0])
            fylkesNavn2019.append(splitLine[1])
            kommuneNr2019.append(splitLine[2])
            kommuneNavn2019.append(splitLine[3])
            fylkesNr2020.append(splitLine[4])
            fylkesNavn2020.append(splitLine[5])
            kommuneNr2020.append(splitLine[6])
            kommuneNavn2020.append(splitLine[7])
        for i in range(len(kommuneNavn2019)):
            if municipalityToGet.lower() in kommuneNavn2019[i].lower():
                countyToGet = fylkesNavn2019[i]
                break
        if countyToGet == "Oslo":
            for i in range(len(kommuneNavn2020)):
                if municipalityToGet.lower() in kommuneNavn2020[i].lower():
                    countyToGet = fylkesNavn2020[i]
                    break

    #people of different ages, index is age, value is number of people
    #Dataset from SSB: "07459: Population, by sex and one-year age groups (M) 1986 - 2020"
    ageDistribution = getAgeDistribution(municipalityToGet,dataDirName)
    if sum(ageDistribution) == 0:
        print("No people found in "+municipalityToGet+", aborting!\n")
        try:
            reportingFile = open("noPopulationMunicipalities.txt","r", encoding = "utf-8")
            munics = reportingFile.readlines()
            reportingFile.close()
            for i in range(len(munics)):
                munics[i] = munics[i].lower()
            if municipalityToGet.lower()+"\n" not in munics:
                reportingFile = open("noPopulationMunicipalities.txt","a", encoding = "utf-8")
                reportingFile.write(municipalityToGet+"\n")
                reportingFile.close()
        except:
            reportingFile = open("noPopulationMunicipalities.txt","w", encoding = "utf-8")
            reportingFile.close()
        # print(munics)
        # print(len(munics))
        return 0

    # print("Age distribution: 67-74: "+str(sum(ageDistribution[67:75]))+", 75-79: "+str(sum(ageDistribution[75:80]))+", 80-84: "+str(sum(ageDistribution[80:85]))+", 85-89: "+str(sum(ageDistribution[85:90]))+", 90+: "+str(sum(ageDistribution[90:])))

    #distribution of household sizes, index+1 is number of people, value is proportion
    #Dataset from SSB: "06079: Private households and persons in private households, by size of household (per cent) (M) (UD) 2005 - 2019"
    householdSizeDistribution = getHouseholdSizeDistribution(countyToGet,dataDirName)

    #distribtion of households: 2 parents, single parents, number of children distribution for each. age?
    #Dataset from SSB: "#06070: Privathusholdninger, etter husholdningstype (K) (B) 2005 - 2019"
    householdTypeDistribution = getHouseHoldTypeDistribution(municipalityToGet,dataDirName)
    #removing two or more-family households with children due to uncertainty around how to integrate data
    householdTypeDistribution[0] = householdTypeDistribution[0][0:8]
    householdTypeDistribution[1] = householdTypeDistribution[1][0:8]

    #distribution on number of siblings in flock
    #Dataset from SSB: "#06206: Children 0-17 years, by number of siblings and the child's age 2001 - 2019"
    siblingFlockSizeDistribution = getSiblingFlockSizeDistribution(dataDirName)

    #proportion of 16-20 YO in upper secondary education
    #Dataset from SSB: "#08947: Pupils, apprentices, students and participants in upper secondary education, by sex, age and type of school/institution 2006 - 2019"
    secondaryEducationProportion = getSecondaryEducationProportion(dataDirName)

    #distribution of workplace sizes
    #Dataset from SSB: "#10308: Establishments, by the enterprises sector and number of employees (M) 2012 - 2020"
    workplaceSizeDistribution = getWorkplaceSizeDistribution(municipalityToGet,dataDirName)

    #distribution of school sizes and types
    # schoolDistributions - [primarySchoolSizes,secondarySchoolSizes,schoolAssociations]
    # schoolAssocations has secondary school ID as index and primary school IDs as value
    # upperSecondarySchoolDistribution - [schoolSize1,schoolSize2,...]
    #Dataset from NSR API: "https://data-nsr.udir.no/"
    schoolDistributions,upperSecondarySchoolDistribution,schoolEmployees = getSchoolSizeDistribution(municipalityToGet,dataDirName)

    #distribution of elderly home sizes and patient number distribution by age
    #Datasets from SSB:
        # "#09929: Nursing and care institutions and beds, by ownership (C) 2009 - 2018"
        # "#04469: Bebuarar i bustader kommunen disponerer til pleie- og omsorgsformÃ¥l, etter alder (K) 2002 - 2018"
        # "#11933: Care institutions - rooms, by region, contents and year"
    nursingHomeSizes,nursingHomePatientDistribution = getElderlyHomeDistribution(municipalityToGet,countyToGet,dataDirName)

    #distribution of kindergartens and kindergarten slots
    #Datasets from SSB:
        # "#09220: Kindergartens, by ownership (M) 1987 - 2019"
        # "#09169: Barn i barnehager, etter region, barnehagetype, statistikkvariabel og Ã¥r"
        # "#12562: Selected key figures kindergartens, by region, contents and year"
    kindergartenSizes,kindergartenProportions = getKindergartenDistribution(municipalityToGet,dataDirName)

    #distribution of number of commuters by work municipality (commuterEmploymentPlaces [homeRegionList,homeRegionNumbers])
    # and number commuters by home municipality (commuterHomePlaces [targetRegionList,targetRegionNumbers])
    commuterEmploymentPlaces,commuterHomePlaces = getCommuteData(municipalityToGet,dataDirName)

    #distribution of working probability by age
    workAgeProbability = getWorkAgeProbability(municipalityToGet,dataDirName)

    for network in range(nNetworks):
        
        #determining fileNumber
        fileNumber = 1
        outputDirName = os.path.dirname(__file__)
        try:
            os.mkdir(outputDirName+"/output/")
        except:
            pass
        outputDirName = outputDirName+"/output/"+municipalityToGet.replace(" ","_")+"/"
        try:
            os.mkdir(outputDirName)
        except:
            pass

        for i in range(nNetworks-1):
            try:
                with open(outputDirName+"idAndAge_"+municipalityToGet.replace(" ","_")+"_"+str(fileNumber)+".txt") as f:
                    test = f.readlines()
                    fileNumber = fileNumber+1
            except IOError:
                break
        
        assert fileNumber<=nNetworks
        
        # # # # #
        # # # # # Building households
        # # # # #

        #finding total numbers of households, adults and children
        numberHouseholds = sum(householdTypeDistribution[1])
        numberUnassignedAdults = sum(ageDistribution[18:])
        numberUnassignedChildren = sum(ageDistribution[0:18])

        # #finding age probability distribution
        # ageProbDist = [x/(numberUnassignedAdults+numberUnassignedChildren) for x in ageDistribution]

        assert numberUnassignedAdults + numberUnassignedChildren == sum(ageDistribution)

        #generating households

        print("Building "+str(numberHouseholds)+" households")

        peopleAgeList = []
        householdPeopleList = []

        householdTypeWeights = copy.deepcopy(householdTypeDistribution[1])
        householdTypePopulation = [x for x in range(len(householdTypeDistribution[0]))]

        householdType0Weights = copy.deepcopy(ageDistribution)
        householdType0Population = range(len(ageDistribution))
        for j in range(len(ageDistribution)):
            #assuming people 19-26 are 1/3 as likely to live alone
            if j>=19 and j<=26:
                householdType0Weights[j] = householdType0Weights[j]*(1/3)
            #assuming people 18 and under don't live alone
            if j<=18:
                householdType0Weights[j] = householdType0Weights[j]*0

        householdType1Weights = copy.deepcopy(ageDistribution)
        householdType1Population = range(len(ageDistribution))
        for j in range(len(ageDistribution)):
            #assuming people 27-50 are 1/3 as likely to be childless
            if j>=27 and j<=50:
                householdType1Weights[j] = householdType1Weights[j]*(1/3)
            #assuming people under 18 don't live as couples
            if j<=18:
                householdType1Weights[j] = householdType1Weights[j]*0

        householdType2Weights = copy.deepcopy(ageDistribution)
        householdType2Population = range(len(ageDistribution)) 
        for j in range(len(ageDistribution)):
            #assuming people under 18 and over 50 don't have small children
            if j<=18 or j>=50:
                householdType2Weights[j] = householdType2Weights[j]*0
            #assuming people 27-45 are 2x as likely to have small children
            if j>=27 and j<=45:
                householdType2Weights[j] = householdType2Weights[j]*2
        #sibling flock size is assumed to be selected from standard distribution
        type2SiblingFlockPopulation = range(len(siblingFlockSizeDistribution))
        type2SiblingFlockWeights = copy.deepcopy(siblingFlockSizeDistribution)
        type2ChildPopulation = range(len(ageDistribution[0:19]))
        type2ChildWeights = ageDistribution[0:19]
        #assuming flocks with younger children are more likely to have younger children
        for i in range(len(type2ChildWeights)):
            if i<6:
                type2ChildWeights[i] = type2ChildWeights[i]*4
        
        householdType3Weights = copy.deepcopy(ageDistribution)
        householdType3Population = range(len(ageDistribution))
        for j in range(len(ageDistribution)):
            #assuming people under 25 and over 65 don't have older children
            if j<=25 or j>=65:
                householdType3Weights[j] = householdType3Weights[j]*0
            #assuming people 30-50 are 1.5 as likely to have children
            if j>=30 and j<=50:
                householdType3Weights[j] = householdType3Weights[j]*1.5
        #sibling flock size is assumed to be between 1 and 3
        type3SiblingFlockPopulation = range(len(siblingFlockSizeDistribution[0:4]))
        type3SiblingFlockWeights = copy.deepcopy(siblingFlockSizeDistribution[0:4])
        type3ChildPopulation = [x for x in range(6,19)]
        type3ChildWeights = ageDistribution[6:19]
        
        householdType4Weights = copy.deepcopy(ageDistribution)
        householdType4Population = range(len(ageDistribution))
        for j in range(len(ageDistribution)):
            #assuming people under 18 and over 50 don't have small children
            if j<=18 or j>=50:
                householdType4Weights[j] = householdType4Weights[j]*0
            #assuming people 30-45 are 2x as likely to have small children
            if j>=30 and j<=45:
                householdType4Weights[j] = householdType4Weights[j]*2
        #sibling flock size is considered 1/4 as likely to be larger than 1
        type4SiblingFlockPopulation = range(len(siblingFlockSizeDistribution))
        type4SiblingFlockWeights = copy.deepcopy(siblingFlockSizeDistribution)
        for j in range(len(siblingFlockSizeDistribution)):
            if j>0:
                type4SiblingFlockWeights[j] = type4SiblingFlockWeights[j]*(1/4)
        type4ChildPopulation = range(len(ageDistribution[0:18]))
        type4ChildWeights = copy.deepcopy(ageDistribution[0:18])
        #assuming flocks with younger children are more likely to have younger children
        for i in range(len(type4ChildWeights)):
            if i<6:
                type4ChildWeights[i] = type4ChildWeights[i]*4

        householdType5Weights = copy.deepcopy(ageDistribution)
        householdType5Population = range(len(ageDistribution))
        for j in range(len(ageDistribution)):
            #assuming people under 25 and over 65 don't have older children
            if j<=25 or j>=65:
                householdType5Weights[j] = householdType5Weights[j]*0
            #assuming people 30-50 are 1.5 as likely to have children
            if j>=30 and j<=50:
                householdType5Weights[j] = householdType5Weights[j]*1.5
        #sibling flock size is assumed to be between 1 and 3, and to be 1/4 as likely to be larger than 1
        type5SiblingFlockPopulation = range(len(siblingFlockSizeDistribution[0:2]))
        type5SiblingFlockWeights = copy.deepcopy(siblingFlockSizeDistribution[0:2])
        for j in range(len(siblingFlockSizeDistribution[0:2])):
            if j>0:
                type5SiblingFlockWeights[j] = type5SiblingFlockWeights[j]*(1/4)
        type5ChildPopulation = range(6,19)
        type5ChildWeights = copy.deepcopy(ageDistribution[6:19])

        householdType6Weights = copy.deepcopy(ageDistribution)
        householdType6Population = range(len(ageDistribution))
        #assuming people with moved-out children are 45 or up
        for j in range(len(ageDistribution)):
            if j<=45:
                householdType6Weights[j] = householdType6Weights[j]*0

        householdType7Weights = copy.deepcopy(ageDistribution)
        householdType7Population = range(len(ageDistribution))
        for j in range(len(ageDistribution)):
            if j<19: #asserting adults-only
                householdType7Weights[j] = householdType7Weights[j]*0
            if j>25: #assuming a significant portion of multi-family households are flatshares
                householdType7Weights[j] = householdType7Weights[j]*0.2

        householdTypeList = random.choices(householdTypePopulation, householdTypeWeights, k=numberHouseholds)
        households = [] #id, age
        peopleIDs = 1
        householdsPicked = [0 for x in range(10)]
        for i in range(numberHouseholds):
            householdType = householdTypeList[i]
            age = -1
            household = []
            if householdType == 0: #Living alone
                householdsPicked[0] = householdsPicked[0]+1
                age = random.choices(householdType0Population, householdType0Weights)
                age = age[0]
                assert age>=19
                household.append([peopleIDs,age])
                peopleIDs = peopleIDs+1
            elif householdType == 1: #Couple without resident children
                householdsPicked[1] = householdsPicked[1]+1
                for j in range(2):
                    age = random.choices(householdType1Population, householdType1Weights)
                    age = age[0]
                    assert age>=18
                    household.append([peopleIDs,age])
                    peopleIDs = peopleIDs+1
            elif householdType == 2: #Couple with small children (youngest child 0-5 years)
                householdsPicked[2] = householdsPicked[2]+1
                #parents' age are assumed to be uncorrelated
                for j in range(2):
                    age = random.choices(householdType2Population, householdType2Weights)
                    age = age[0]
                    assert age>=18 and age <=50
                    household.append([peopleIDs,age])
                    peopleIDs = peopleIDs+1
                flockSize = random.choices(type2SiblingFlockPopulation, type2SiblingFlockWeights)
                flockSize = flockSize[0]+1 #adding +1 since index 0 is size 1
                for j in range(flockSize):
                    age = random.choices(type2ChildPopulation, type2ChildWeights)
                    age = age[0]
                    assert age>=0 and age<=18
                    household.append([peopleIDs,age])
                    peopleIDs = peopleIDs+1
            elif householdType == 3: #Couple with older children (youngest child 6-17 years)
                householdsPicked[3] = householdsPicked[3]+1
                #parents' age are assumed to be uncorrelated
                for j in range(2):
                    age = random.choices(householdType3Population, householdType3Weights)
                    age = age[0]
                    assert age>=25 and age<=65
                    household.append([peopleIDs,age])
                    peopleIDs = peopleIDs+1
                flockSize = random.choices(type3SiblingFlockPopulation, type3SiblingFlockWeights)
                flockSize = flockSize[0]+1 #adding +1 since index 0 is size 1
                for j in range(flockSize):
                    age = random.choices(type3ChildPopulation, type3ChildWeights)
                    age = age[0]
                    assert age>=6 and age<=18
                    household.append([peopleIDs,age])
                    peopleIDs = peopleIDs+1
            elif householdType == 4: #Lone parent with small children (youngest child 0-5 years)
                householdsPicked[4] = householdsPicked[4]+1
                age = random.choices(householdType4Population, householdType4Weights)
                age = age[0]
                assert age>=18 and age<=60
                household.append([peopleIDs,age])
                peopleIDs = peopleIDs+1
                flockSize = random.choices(type4SiblingFlockPopulation, type4SiblingFlockWeights)
                flockSize = flockSize[0]+1 #adding +1 since index 0 is size 1
                for j in range(flockSize):
                    age = random.choices(type4ChildPopulation, type4ChildWeights)
                    age = age[0]
                    assert age>=0 and age<=17
                    household.append([peopleIDs,age])
                    peopleIDs = peopleIDs+1
            elif householdType == 5: #Lone parent with older children (youngest child 6-17 years)
                householdsPicked[5] = householdsPicked[5]+1
                age = random.choices(householdType5Population, householdType5Weights)
                age = age[0]
                assert age>=25 and age<=65
                household.append([peopleIDs,age])
                peopleIDs = peopleIDs+1
                flockSize = random.choices(type5SiblingFlockPopulation, type5SiblingFlockWeights) #adding +1 since index 0 is size 1
                flockSize = flockSize[0]+1 #adding +1 since index 0 is size 1
                assert flockSize>=1 and flockSize<=3
                for j in range(flockSize):
                    age = random.choices(type5ChildPopulation, type5ChildWeights)
                    age = age[0]
                    assert age>=6 and age<=18
                    household.append([peopleIDs,age])
                    peopleIDs = peopleIDs+1
            elif householdType == 6: #One family households with adult children (youngest child 18 years and over
                householdsPicked[6] = householdsPicked[6]+1
                for j in range(2):
                    age = random.choices(householdType6Population, householdType6Weights)
                    age = age[0]
                    assert age>=45
                    household.append([peopleIDs,age])
                    peopleIDs = peopleIDs+1 
            elif householdType == 7: #Two or more-family households without resident children 0-17 years
                householdsPicked[7] = householdsPicked[7]+1
                numberOfPeople = random.randint(3,6) #assuming these households have somewhere between 3 and 6 people
                assert numberOfPeople>=3 and numberOfPeople<=6
                for j in range(numberOfPeople):
                    age = random.choices(householdType7Population, householdType7Weights)
                    age = age[0]
                    assert age>=19
                    household.append([peopleIDs,age])
                    peopleIDs = peopleIDs+1
            else:
                raise Exception("Missing case in household type selection")
            # elif householdType == 7:
            #     #Two or more-family households without resident children 0-17 years
            # elif householdType == 8:
            #     #Two or more-family households with small children (youngest child 0-5 years)
            # elif householdType == 9:
            #     #Two or more-family households with older children (youngest child 6-17 years)'
            for person in household:
                peopleAgeList.append(person)
                householdPeopleList.append([i,person[0]])
            households.append(household)

        print("Assigning households and people to schools and kindergartens")
        #assigning households to lower secondary schools
        #schoolDistributions - [primarySchoolSizes,secondarySchoolSizes,schoolAssociations] #schoolAssocations has secondary school ID as index and primary school IDs as value
        householdsSchoolAffiliation = []
        population = range(len(schoolDistributions[1]))
        weights = copy.deepcopy(schoolDistributions[1])
        for i in range(numberHouseholds):
            schoolIndex = random.choices(population, weights)
            schoolIndex = schoolIndex[0]
            householdsSchoolAffiliation.append(schoolIndex)

        #assigning children to kindergartens
        #assigning kids to kindergartens randomly according to size weights and age attendance proportion
        #kindergartenSizes - [size1, size2, ...]
        kindergartens = [[] for x in range(len(kindergartenSizes))]
        population = range(len(kindergartens))
        weights = copy.deepcopy(kindergartenSizes)
        for hh in households:
            #assigning household to kindergarten
            kindergartenIndex = random.choices(population, weights)
            kindergartenIndex = kindergartenIndex[0]
            kindergartenAttendants = []
            for person in hh:
                if person[1] > 0 and person[1] < 6:
                    personId = person[0]
                    personAge = person[1]
                    kindergartenAttendants.append([personId,personAge,0])
                    #taking into account the proportional attendance by age and region
                    if random.randint(0,100) < 100*kindergartenProportions[personAge]:
                        kindergartenAttendants[-1][2] = 1
                    else:
                        #making sure that younger siblings of kindergarten non-attendants do also not attend kindergarten
                        for attendant in kindergartenAttendants:
                            if attendant[1]<personAge:
                                attendant[2] = 0
            for attendant in kindergartenAttendants:
                if attendant[2] == 1:
                    kindergartens[kindergartenIndex].append(attendant[0])

        #assigning children to schools
        primarySchools = [[] for x in range(len(schoolDistributions[0]))]
        secondarySchools = [[] for x in range(len(schoolDistributions[1]))]
        upperSecondarySchools = [[] for x in range(len(upperSecondarySchoolDistribution))]
        #households - [[[personID,age],[personID,age],...],[[personID,age],[personID,age],...],...]
        for hh in range(len(households)):
            for p in range(len(households[hh])):
                if households[hh][p][1]>=6 and households[hh][p][1]<=12:
                    primarySchoolIDsForHousehold = schoolDistributions[2][householdsSchoolAffiliation[hh]]
                    primarySchoolID = 0
                    if len(primarySchoolIDsForHousehold)!=1:
                        assert len(primarySchoolIDsForHousehold)>0
                        population = primarySchoolIDsForHousehold
                        weights = [schoolDistributions[0][primarySchoolIDsForHousehold[x]] for x in range(len(primarySchoolIDsForHousehold))]
                        schoolIndex = random.choices(population, weights)
                        schoolIndex = schoolIndex[0]
                    primarySchools[primarySchoolIDsForHousehold[primarySchoolID]].append(households[hh][p][0])
                elif households[hh][p][1]>=13 and households[hh][p][1]<=15:
                    secondarySchools[householdsSchoolAffiliation[hh]].append(households[hh][p][0])
                elif households[hh][p][1]>=16 and households[hh][p][1]<=19 and sum(upperSecondarySchoolDistribution)>0:
                    if random.randint(0,100)<100*secondaryEducationProportion:
                        population = range(len(upperSecondarySchoolDistribution))
                        weights = copy.deepcopy(upperSecondarySchoolDistribution)
                        schoolIndex = random.choices(population, weights)
                        schoolIndex = schoolIndex[0]
                        upperSecondarySchools[schoolIndex].append(households[hh][p][0])

        #putting ages in bins and assigning probabilities they work
        # warnings.warn("WARNING! Probability that people are working at given ages is guesstimate!")
        # workAgeProbability = [[0,15,0],[16,22,30],[23,28,60],[29,65,90],[66,70,30],[71,110,0]]

        #generating workforce
        print("Assigning people to workplaces")
        workforce = []
        for i in range(len(peopleAgeList)):
            personID = peopleAgeList[i][0]
            personAge = peopleAgeList[i][1]
            for j in range(len(workAgeProbability)):
                ageIntervalLowerBound = workAgeProbability[j][0]
                ageIntervalUpperBound = workAgeProbability[j][1]
                ageIntervalWorkingProbability = workAgeProbability[j][2]
                if personAge>=ageIntervalLowerBound and personAge<=ageIntervalUpperBound:
                    if random.randint(0,100)<ageIntervalWorkingProbability:
                        workforce.append(personID)
        random.shuffle(workforce) # this is important! or else people are bunched into workplaces by household etc.
        
        #assigning elderly to nursing homes
        #Elderly in nursing homes are not part of households!
        #This code is run after generating the workforce so that no further sorting will be necessary
        #nursingHomeSizes - [size1,size2,...]
        #nursingHomePatientDistribution - [[string with age category],[number of patients in category]]
        nursingHomes = [[] for x in range(len(nursingHomeSizes))]
        population = range(len(nursingHomeSizes))
        weights = copy.deepcopy(nursingHomeSizes)
        ageWeights = copy.deepcopy(nursingHomePatientDistribution[1])
        agePopulation = range(len(nursingHomePatientDistribution[1]))
        for i in range(sum(nursingHomePatientDistribution[1])):
            #ageBins = ["Under 67 years","67-74 years","75-79 years","80-84 years","85-89 years","90 years or older"]
            personAgeCat = random.choices(agePopulation, ageWeights)
            personAgeCat = personAgeCat[0]
            personAge = 0
            if personAgeCat == 0:
                pass
                # personAge = random.randint(50,66) #seems a quite large number falls into this category, i.e. not elderly homes
            elif personAgeCat == 1:
                personAge = random.randint(67,74)
            elif personAgeCat == 2:
                personAge = random.randint(75,79)
            elif personAgeCat == 3:
                personAge = random.randint(80,84)
            elif personAgeCat == 4:
                personAge = random.randint(85,89)
            elif personAgeCat == 5:
                personAge = random.randint(90,105)
            if personAgeCat != 0:
                nIndex = random.choices(population, weights)
                nIndex = nIndex[0]
                nursingHomes[nIndex].append(peopleIDs)
                peopleAgeList.append([peopleIDs,personAge])
                peopleIDs = peopleIDs+1

        #setting up workplaces
        workplaces = []
        workerIterator = 0

        #assigning people to commuter OUT workplaces

        #commuterEmploymentPlaces [homeRegionList,homeRegionNumbers]
        commuterEmployments = [] #[[place,[peopleIds]],[place,[peopleIds]],...]
        for place in range(len(commuterEmploymentPlaces[0])):
            if commuterEmploymentPlaces[1][place]>0:
                workplace = commuterEmploymentPlaces[0][place]
                workforceForPlace = workforce[workerIterator:workerIterator+commuterEmploymentPlaces[1][place]]
                commuterEmployments.append([workplace,workforceForPlace])
                workerIterator = workerIterator+commuterEmploymentPlaces[1][place]

        #adding commuters IN to workforce
        #commuterHomePlaces [targetRegionList,targetRegionNumbers]
        for commuterHome in range(len(commuterHomePlaces[0])):
            if commuterHomePlaces[1][commuterHome] > 0:
                for i in range(commuterHomePlaces[1][commuterHome]):
                    workforce.append(commuterHomePlaces[0][commuterHome]+str(i))
        
        #hack to shuffle commuters into rest of remaining workforce to avoid clustering commuters
        workforce = workforce[workerIterator:]
        random.shuffle(workforce)
        workerIterator = 0

        #assigning people as teachers to schools
        # primarySchools = [[] for x in range(len(schoolDistributions[0]))]
        # secondarySchools = [[] for x in range(len(schoolDistributions[1]))]
        # upperSecondarySchools = [[] for x in range(len(upperSecondarySchoolDistribution))]
        # schoolEmployees = [primarySchoolEmployees,secondarySchoolEmployees,upperSecondarySchoolEmployees]
        for school in primarySchools:
            for i in range(len(schoolEmployees[0])):
                school.append(workforce[workerIterator])
                workerIterator = workerIterator+1
        for school in secondarySchools:
            for i in range(len(schoolEmployees[1])):
                school.append(workforce[workerIterator])
                workerIterator = workerIterator+1
        for school in upperSecondarySchools:
            for i in range(len(schoolEmployees[2])):
                school.append(workforce[workerIterator])
                workerIterator = workerIterator+1

        #assigning people as teachers in kindergartens
        # approximately 5.5 employees per child based on 12562: Selected key figures kindergartens, by region, contents and year (M)
        for kindergarten in kindergartens:
            kindergartenWorkers = int(math.ceil(len(kindergarten)/5.5))
            for i in range(kindergartenWorkers):
                kindergarten.append(workforce[workerIterator])
                workerIterator = workerIterator+1

        #assigning people as nurses in nursing home
        # assuming a "bemanningsfaktor" of 0.75 based on anecdotal information
        for nursingHome in nursingHomes:
            for employee in range(int(len(nursingHome)*0.75)):
                nursingHome.append(workforce[workerIterator])
                workerIterator = workerIterator+1
        #assigning people to other in-municipality workplaces
        population = range(len(workplaceSizeDistribution[1]))
        weights = (workplaceSizeDistribution[1])
            # drawing random workplace size category according to distribution
            # assuming uniform distribution of workplace sizes within size categories!

        while 1:
            workplaceSizeCategory = random.choices(population, weights)
            workplaceSizeCategory = workplaceSizeCategory[0]
            workplaceSize = 0
            if workplaceSizeCategory == 0:
                workplaceSize = random.randint(1, 4)
            elif workplaceSizeCategory == 1:
                workplaceSize = random.randint(5, 9)
            elif workplaceSizeCategory == 2:
                workplaceSize = random.randint(10, 19)
            elif workplaceSizeCategory == 3:
                workplaceSize = random.randint(20, 49)
            elif workplaceSizeCategory == 4:
                workplaceSize = random.randint(50, 99)
            elif workplaceSizeCategory == 5:
                workplaceSize = random.randint(100, 249)
            elif workplaceSizeCategory == 6:
                #setting upper cap on workplace at 500, more or less at random
                workplaceSize = random.randint(250, 500)
            else:
                raise Exception("WorkplaceSizeCategory out of bounds!")
            workplace = []
            if workerIterator+workplaceSize>len(workforce):
                workplaceSize = len(workforce)-workerIterator
            for i in range(workplaceSize):
                workplace.append(workforce[workerIterator+i])
            workerIterator = workerIterator+workplaceSize
            workplaces.append(workplace)
            if workerIterator >= len(workforce)-1:
                break



        idAndAgeFileName = outputDirName+"idAndAge_"+municipalityToGet.replace(" ","_")+"_"+str(fileNumber)+".txt"
        socialNetworkFileName = outputDirName+"socialNetwork_"+municipalityToGet.replace(" ","_")+"_"+str(fileNumber)+".txt"

        # peopleAgeList - [[personID,age],...]
        outputFile = open(idAndAgeFileName, "w", encoding='utf8')
        for person in peopleAgeList:
            outputFile.write(str(person[0])+";"+str(person[1])+"\n")
        outputFile.close()

        outputFile = open(socialNetworkFileName, "w", encoding='utf8')
        
        # households - [[[personID,age],[personID,age],...],[[personID,age],[personID,age],...],...]
        for hh in households:
            if len(hh)>0:
                householdString = ""
                for person in hh:
                    householdString = householdString+";"+str(person[0])
                outputFile.write("Household"+householdString+"\n")
            # else:
            #     print("Empty household")
        # primarySchools = [[personID,personID,...],[personID,personID,...]...]
        for school in primarySchools:
            if len(school)>0:
                outputFile.write("PrimarySchool;"+';'.join([str(person) for person in school])+"\n")
            # else:
            #     print("Empty primary school")
        # secondarySchools = [[personID,personID,...],[personID,personID,...]...]
        for school in secondarySchools:
            if len(school)>0:
                outputFile.write("SecondarySchool;"+';'.join([str(person) for person in school])+"\n")
            # else:
            #     print("Empty secondary school")
        # upperSecondarySchools = [[personID,personID,...],[personID,personID,...]...]
        for school in upperSecondarySchools:
            if len(school)>0:
                outputFile.write("UpperSecondarySchool;"+';'.join([str(person) for person in school])+"\n")
            # else:
            #     print("Empty upper secondary school")
        # workplaces - [[personID,...],[personID,...],...]
        for workplace in workplaces:
            if len(workplace)>0:
                outputFile.write("Workplace;"+';'.join([str(person) for person in workplace])+"\n")
            # else:
            #     print("Empty workplace")
        for commuterPlace in commuterEmployments:
            #[[place,[peopleIds]],[place,[peopleIds]],...]
            if len(commuterPlace)>0:
                outputFile.write("Commuters_"+commuterPlace[0]+";"+";".join([str(person) for person in commuterPlace[1]])+"\n")
            else:
                print("Empty workplace")
        # nursingHomes - [[personID,personID,...],[personID,personID,...]]
        for nursingHome in nursingHomes:
            if len(nursingHome)>0:
                outputFile.write("NursingHome;"+';'.join([str(person) for person in nursingHome])+"\n")
            # else:
            #     print("Empty nursing home")
        # kindergartens - [[personID,personID,...],[personID,personID,...]]
        for kindergarten in kindergartens:
            if len(kindergarten)>0:
                outputFile.write("Kindergarten;"+';'.join([str(person) for person in kindergarten])+"\n")
            # else:
            #     print("Empty kindergarten")
        outputFile.close()
        print("Network for "+municipalityToGet+" generated")
        print("Put "+str(len(peopleAgeList))+" people in "+municipalityToGet+" in "+str(len(households))+" households, "+str(len(kindergartens))+" kindergartens, "+str(len(primarySchools))+" primary schools, "+str(len(secondarySchools))+" lower secondary schools, "+str(len(upperSecondarySchools))+" upper secondary schools, "+str(len(workplaces))+" workplaces, and "+str(len(nursingHomes))+" nursing homes.")
        reportFile = open("statusReport.txt","a",encoding = "utf-8")
        reportFile.write("Put "+str(len(peopleAgeList))+" people in "+municipalityToGet+" in "+str(len(households))+" households, "+str(len(kindergartens))+" kindergartens, "+str(len(primarySchools))+" primary schools, "+str(len(secondarySchools))+" lower secondary schools, "+str(len(upperSecondarySchools))+" upper secondary schools, "+str(len(workplaces))+" workplaces, and "+str(len(nursingHomes))+" nursing homes.\n")
        reportFile.close()
        reportFile = open("statusCheck.csv","a",encoding = "utf-8")
        reportFile.write(municipalityToGet+","+str(len(peopleAgeList))+","+str(len(households))+","+str(len(kindergartens))+","+str(len(primarySchools))+","+str(len(secondarySchools))+","+str(len(upperSecondarySchools))+","+str(len(workplaces))+","+str(len(nursingHomes))+"\n")
        reportFile.close()
        print("")

        if fileNumber == nNetworks:
            print(str(nNetworks)+" files generated for "+municipalityToGet+"\n")
            return 0

    ###########################
    # generatedAgeDistribution = [0 for x in range(106)]
    # for i in range(len(peopleAgeList)):
    #     try:
    #         generatedAgeDistribution[peopleAgeList[i][1]] = generatedAgeDistribution[peopleAgeList[i][1]]+1
    #     except:
    #         print("EXCEPTION")
    #         print(peopleAgeList[i][1])

    # outputFile = open("ageDistCheck"+municipalityToGet+".csv", "w")
    # outputFile.write("RealAges,GeneratedAges\n")
    # for i in range(106):
    #     outputFile.write(str(ageDistribution[i])+","+str(generatedAgeDistribution[i])+"\n")
    # outputFile.close()
    ###########################

    #save in file: cliqueType;id1;id2;...
    #e.g.:
    # Household 1 2 3 4 5 6
    # Household 7 8
    # Work 1 7 11
    # Work 2, 10, 14, 15
    # School 3, 13, 19, 24

    #separate file: id;age
    #e.g.:
    # 0;14
    # 1;32
    # 2;21

    #TODO:
    #   Make output be for new municipalities?
    #   Restructure the ways schools are made so that age groupings match empirical data more closely
    #   Integrate householdSizeDistribution
    #   Add hospitals
    #   School data missing for some municipalities due to outdated municipality names
    #       - Kommune (Legacy): https://data-nxr-fellestjeneste.udir.no/swagger/ui/index
    #   More data on kindergartens
    #       - https://data-nbr.udir.no/swagger/ui/index
    #   Add sanity checks (demographic distribution vs original data, etc)
    #   Find and implement better data for compositions of couples, families, sibling flocks etc.
    #   Find better school data? (replace 4.5 hack) https://www.udir.no/tall-og-forskning/statistikk/statistikk-videregaende-skole/elevtall-i-videregaende-skole/elevtall-fylker-og-skoler/

def allMunicipalities(nTimes):
    kommuneNavnFil = open("populationData/kommuneNavnFixed2019.txt", "r", encoding='utf-8')
    kommuneNavn = kommuneNavnFil.readlines()
    kommuneNavnFil.close()

    fullTime = time.time()
    fullStart = time.time()

    for kommune in kommuneNavn:
        kommune = kommune.replace("\n","")
        try:
            generateSocialNetworkForRegion(kommune,nTimes)
        except:
            try:
                reportingFile = open("municipalitiesNotWorking.txt","r", encoding = "utf-8")
                munics = reportingFile.readlines()
                reportingFile.close()
                if kommune+"\n" not in munics:
                    reportingFile = open("municipalitiesNotWorking.txt","a", encoding = "utf-8")
                    reportingFile.write(kommune+"\n")
                    reportingFile.close()
            except:
                reportingFile = open("municipalitiesNotWorking.txt","w", encoding = "utf-8")
                reportingFile.close()

    fullEnd = time.time()
    fullTime = fullEnd - fullStart
    print(fullTime)
    fullMinutes = str(math.floor(fullTime/60))
    fullSeconds = str(int(fullTime%60))
    print("Time elapsed, full: "+fullMinutes+" minutes and "+fullSeconds+" seconds")


# pr = cProfile.Profile()
# pr.enable()
# start = time.time()
# #
allMunicipalities(1)
# generateSocialNetworkForRegion("Halden",100)
# #
# end = time.time()
# pr.disable()
# s = StringIO()
# sortby = 'cumulative'
# ps = pstats.Stats(pr, stream=s).sort_stats(sortby)
# ps.print_stats()
# print(s.getvalue())
# print("Total time: "+str(end-start))